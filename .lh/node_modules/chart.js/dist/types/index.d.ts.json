{
    "sourceFile": "node_modules/chart.js/dist/types/index.d.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1703582720074,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1703582720074,
            "name": "Commit-0",
            "content": "/* eslint-disable @typescript-eslint/ban-types */\nimport {DeepPartial, DistributiveArray, UnionToIntersection} from './utils.js';\n\nimport {TimeUnit} from '../core/core.adapters.js';\nimport PointElement from '../elements/element.point.js';\nimport {EasingFunction} from '../helpers/helpers.easing.js';\nimport {AnimationEvent} from './animation.js';\nimport {AnyObject, EmptyObject} from './basic.js';\nimport {Color} from './color.js';\nimport Element from '../core/core.element.js';\nimport {ChartArea, Padding, Point} from './geometric.js';\nimport {LayoutItem, LayoutPosition} from './layout.js';\nimport {ColorsPluginOptions} from '../plugins/plugin.colors.js';\n\nexport {EasingFunction} from '../helpers/helpers.easing.js';\nexport {default as ArcElement, ArcProps} from '../elements/element.arc.js';\nexport {default as PointElement, PointProps} from '../elements/element.point.js';\nexport {Animation, Animations, Animator, AnimationEvent} from './animation.js';\nexport {Color} from './color.js';\nexport {ChartArea, Point} from './geometric.js';\nexport {LayoutItem, LayoutPosition} from './layout.js';\n\nexport interface ScriptableContext<TType extends ChartType> {\n  active: boolean;\n  chart: Chart;\n  dataIndex: number;\n  dataset: UnionToIntersection<ChartDataset<TType>>;\n  datasetIndex: number;\n  type: string;\n  mode: string;\n  parsed: UnionToIntersection<ParsedDataType<TType>>;\n  raw: unknown;\n}\n\nexport interface ScriptableLineSegmentContext {\n  type: 'segment',\n  p0: PointElement,\n  p1: PointElement,\n  p0DataIndex: number,\n  p1DataIndex: number,\n  datasetIndex: number\n}\n\nexport type Scriptable<T, TContext> = T | ((ctx: TContext, options: AnyObject) => T | undefined);\nexport type ScriptableOptions<T, TContext> = { [P in keyof T]: Scriptable<T[P], TContext> };\nexport type ScriptableAndScriptableOptions<T, TContext> = Scriptable<T, TContext> | ScriptableOptions<T, TContext>;\nexport type ScriptableAndArray<T, TContext> = readonly T[] | Scriptable<T, TContext>;\nexport type ScriptableAndArrayOptions<T, TContext> = { [P in keyof T]: ScriptableAndArray<T[P], TContext> };\n\nexport interface ParsingOptions {\n  /**\n   * How to parse the dataset. The parsing can be disabled by specifying parsing: false at chart options or dataset. If parsing is disabled, data must be sorted and in the formats the associated chart type and scales use internally.\n   */\n  parsing:\n  {\n    [key: string]: string;\n  }\n  | false;\n\n  /**\n   * Chart.js is fastest if you provide data with indices that are unique, sorted, and consistent across datasets and provide the normalized: true option to let Chart.js know that you have done so.\n   */\n  normalized: boolean;\n}\n\nexport interface ControllerDatasetOptions extends ParsingOptions {\n  /**\n   * The base axis of the chart. 'x' for vertical charts and 'y' for horizontal charts.\n   * @default 'x'\n   */\n  indexAxis: 'x' | 'y';\n  /**\n   * How to clip relative to chartArea. Positive value allows overflow, negative value clips that many pixels inside chartArea. 0 = clip at chartArea. Clipping can also be configured per side: `clip: {left: 5, top: false, right: -2, bottom: 0}`\n   */\n  clip: number | ChartArea | false;\n  /**\n   * The label for the dataset which appears in the legend and tooltips.\n   */\n  label: string;\n  /**\n   * The drawing order of dataset. Also affects order for stacking, tooltip and legend.\n   */\n  order: number;\n\n  /**\n   * The ID of the group to which this dataset belongs to (when stacked, each group will be a separate stack).\n   */\n  stack: string;\n  /**\n     * Configures the visibility state of the dataset. Set it to true, to hide the dataset from the chart.\n   * @default false\n   */\n  hidden: boolean;\n}\n\nexport interface BarControllerDatasetOptions\n  extends ControllerDatasetOptions,\n  ScriptableAndArrayOptions<BarOptions, ScriptableContext<'bar'>>,\n  ScriptableAndArrayOptions<CommonHoverOptions, ScriptableContext<'bar'>>,\n  AnimationOptions<'bar'> {\n  /**\n   * The ID of the x axis to plot this dataset on.\n   */\n  xAxisID: string;\n  /**\n   * The ID of the y axis to plot this dataset on.\n   */\n  yAxisID: string;\n\n  /**\n   * Percent (0-1) of the available width each bar should be within the category width. 1.0 will take the whole category width and put the bars right next to each other.\n   * @default 0.9\n   */\n  barPercentage: number;\n  /**\n   * Percent (0-1) of the available width each category should be within the sample width.\n   * @default 0.8\n   */\n  categoryPercentage: number;\n\n  /**\n   * Manually set width of each bar in pixels. If set to 'flex', it computes \"optimal\" sample widths that globally arrange bars side by side. If not set (default), bars are equally sized based on the smallest interval.\n   */\n  barThickness: number | 'flex';\n\n  /**\n   * Set this to ensure that bars are not sized thicker than this.\n   */\n  maxBarThickness: number;\n\n  /**\n   * Set this to ensure that bars have a minimum length in pixels.\n   */\n  minBarLength: number;\n\n  /**\n   * Point style for the legend\n   * @default 'circle;\n   */\n  pointStyle: PointStyle;\n\n  /**\n   * Should the bars be grouped on index axis\n   * @default true\n   */\n  grouped: boolean;\n}\n\nexport interface BarControllerChartOptions {\n  /**\n   * Should null or undefined values be omitted from drawing\n   */\n  skipNull?: boolean;\n}\n\nexport type BarController = DatasetController\nexport declare const BarController: ChartComponent & {\n  prototype: BarController;\n  new (chart: Chart, datasetIndex: number): BarController;\n};\n\nexport interface BubbleControllerDatasetOptions\n  extends ControllerDatasetOptions,\n  ScriptableAndArrayOptions<PointOptions, ScriptableContext<'bubble'>>,\n  ScriptableAndArrayOptions<PointHoverOptions, ScriptableContext<'bubble'>> {\n  /**\n   * The ID of the x axis to plot this dataset on.\n   */\n  xAxisID: string;\n  /**\n   * The ID of the y axis to plot this dataset on.\n   */\n  yAxisID: string;\n}\n\nexport interface BubbleDataPoint extends Point {\n  /**\n   * Bubble radius in pixels (not scaled).\n   */\n  r: number;\n}\n\nexport type BubbleController = DatasetController\nexport declare const BubbleController: ChartComponent & {\n  prototype: BubbleController;\n  new (chart: Chart, datasetIndex: number): BubbleController;\n};\n\nexport interface LineControllerDatasetOptions\n  extends ControllerDatasetOptions,\n  ScriptableAndArrayOptions<PointPrefixedOptions, ScriptableContext<'line'>>,\n  ScriptableAndArrayOptions<PointPrefixedHoverOptions, ScriptableContext<'line'>>,\n  ScriptableOptions<Omit<LineOptions, keyof CommonElementOptions>, ScriptableContext<'line'>>,\n  ScriptableAndArrayOptions<CommonElementOptions, ScriptableContext<'line'>>,\n  ScriptableOptions<Omit<LineHoverOptions, keyof CommonHoverOptions>, ScriptableContext<'line'>>,\n  ScriptableAndArrayOptions<CommonHoverOptions, ScriptableContext<'line'>>,\n  AnimationOptions<'line'> {\n  /**\n   * The ID of the x axis to plot this dataset on.\n   */\n  xAxisID: string;\n  /**\n   * The ID of the y axis to plot this dataset on.\n   */\n  yAxisID: string;\n\n  /**\n   * If true, lines will be drawn between points with no or null data. If false, points with NaN data will create a break in the line. Can also be a number specifying the maximum gap length to span. The unit of the value depends on the scale used.\n   * @default false\n   */\n  spanGaps: boolean | number;\n\n  showLine: boolean;\n}\n\nexport interface LineControllerChartOptions {\n  /**\n   * If true, lines will be drawn between points with no or null data. If false, points with NaN data will create a break in the line. Can also be a number specifying the maximum gap length to span. The unit of the value depends on the scale used.\n   * @default false\n   */\n  spanGaps: boolean | number;\n  /**\n   * If false, the lines between points are not drawn.\n   * @default true\n   */\n  showLine: boolean;\n}\n\nexport type LineController = DatasetController\nexport declare const LineController: ChartComponent & {\n  prototype: LineController;\n  new (chart: Chart, datasetIndex: number): LineController;\n};\n\nexport type ScatterControllerDatasetOptions = LineControllerDatasetOptions;\n\nexport type ScatterDataPoint = Point\n\nexport type ScatterControllerChartOptions = LineControllerChartOptions;\n\nexport type ScatterController = LineController\nexport declare const ScatterController: ChartComponent & {\n  prototype: ScatterController;\n  new (chart: Chart, datasetIndex: number): ScatterController;\n};\n\nexport interface DoughnutControllerDatasetOptions\n  extends ControllerDatasetOptions,\n  ScriptableAndArrayOptions<ArcOptions, ScriptableContext<'doughnut'>>,\n  ScriptableAndArrayOptions<ArcHoverOptions, ScriptableContext<'doughnut'>>,\n  AnimationOptions<'doughnut'> {\n\n  /**\n   * Sweep to allow arcs to cover.\n   * @default 360\n   */\n  circumference: number;\n\n  /**\n   * Arc offset (in pixels).\n   */\n  offset: number | number[];\n\n  /**\n   * Starting angle to draw this dataset from.\n   * @default 0\n   */\n  rotation: number;\n\n  /**\n   * The relative thickness of the dataset. Providing a value for weight will cause the pie or doughnut dataset to be drawn with a thickness relative to the sum of all the dataset weight values.\n   * @default 1\n   */\n  weight: number;\n\n  /**\n   * Similar to the `offset` option, but applies to all arcs. This can be used to to add spaces\n   * between arcs\n   * @default 0\n   */\n  spacing: number;\n}\n\nexport interface DoughnutAnimationOptions {\n  /**\n   *   If true, the chart will animate in with a rotation animation. This property is in the options.animation object.\n   * @default true\n   */\n  animateRotate: boolean;\n\n  /**\n   * If true, will animate scaling the chart from the center outwards.\n   * @default false\n   */\n  animateScale: boolean;\n}\n\nexport interface DoughnutControllerChartOptions {\n  /**\n   * Sweep to allow arcs to cover.\n   * @default 360\n   */\n  circumference: number;\n\n  /**\n   * The portion of the chart that is cut out of the middle. ('50%' - for doughnut, 0 - for pie)\n   * String ending with '%' means percentage, number means pixels.\n   * @default 50\n   */\n  cutout: Scriptable<number | string, ScriptableContext<'doughnut'>>;\n\n  /**\n   * Arc offset (in pixels).\n   */\n  offset: number | number[];\n\n  /**\n   * The outer radius of the chart. String ending with '%' means percentage of maximum radius, number means pixels.\n   * @default '100%'\n   */\n  radius: Scriptable<number | string, ScriptableContext<'doughnut'>>;\n\n  /**\n   * Starting angle to draw arcs from.\n   * @default 0\n   */\n  rotation: number;\n\n  /**\n   * Spacing between the arcs\n   * @default 0\n   */\n  spacing: number;\n\n  animation: false | DoughnutAnimationOptions;\n}\n\nexport type DoughnutDataPoint = number;\n\nexport interface DoughnutController extends DatasetController {\n  readonly innerRadius: number;\n  readonly outerRadius: number;\n  readonly offsetX: number;\n  readonly offsetY: number;\n\n  calculateTotal(): number;\n  calculateCircumference(value: number): number;\n}\n\nexport declare const DoughnutController: ChartComponent & {\n  prototype: DoughnutController;\n  new (chart: Chart, datasetIndex: number): DoughnutController;\n};\n\nexport interface DoughnutMetaExtensions {\n  total: number;\n}\n\nexport type PieControllerDatasetOptions = DoughnutControllerDatasetOptions;\nexport type PieControllerChartOptions = DoughnutControllerChartOptions;\nexport type PieAnimationOptions = DoughnutAnimationOptions;\n\nexport type PieDataPoint = DoughnutDataPoint;\nexport type PieMetaExtensions = DoughnutMetaExtensions;\n\nexport type PieController = DoughnutController\nexport declare const PieController: ChartComponent & {\n  prototype: PieController;\n  new (chart: Chart, datasetIndex: number): PieController;\n};\n\nexport interface PolarAreaControllerDatasetOptions extends DoughnutControllerDatasetOptions {\n  /**\n   * Arc angle to cover. - for polar only\n   * @default circumference / (arc count)\n   */\n  angle: number;\n}\n\nexport type PolarAreaAnimationOptions = DoughnutAnimationOptions;\n\nexport interface PolarAreaControllerChartOptions {\n  /**\n   * Starting angle to draw arcs for the first item in a dataset. In degrees, 0 is at top.\n   * @default 0\n   */\n  startAngle: number;\n\n  animation: false | PolarAreaAnimationOptions;\n}\n\nexport interface PolarAreaController extends DoughnutController {\n  countVisibleElements(): number;\n}\nexport declare const PolarAreaController: ChartComponent & {\n  prototype: PolarAreaController;\n  new (chart: Chart, datasetIndex: number): PolarAreaController;\n};\n\nexport interface RadarControllerDatasetOptions\n  extends ControllerDatasetOptions,\n  ScriptableAndArrayOptions<PointOptions & PointHoverOptions & PointPrefixedOptions & PointPrefixedHoverOptions, ScriptableContext<'radar'>>,\n  ScriptableAndArrayOptions<LineOptions & LineHoverOptions, ScriptableContext<'radar'>>,\n  AnimationOptions<'radar'> {\n  /**\n   * The ID of the x axis to plot this dataset on.\n   */\n  xAxisID: string;\n  /**\n   * The ID of the y axis to plot this dataset on.\n   */\n  yAxisID: string;\n\n  /**\n   * If true, lines will be drawn between points with no or null data. If false, points with NaN data will create a break in the line. Can also be a number specifying the maximum gap length to span. The unit of the value depends on the scale used.\n   */\n  spanGaps: boolean | number;\n\n  /**\n   * If false, the line is not drawn for this dataset.\n   */\n  showLine: boolean;\n}\n\nexport type RadarControllerChartOptions = LineControllerChartOptions;\n\nexport type RadarController = DatasetController\nexport declare const RadarController: ChartComponent & {\n  prototype: RadarController;\n  new (chart: Chart, datasetIndex: number): RadarController;\n};\ninterface ChartMetaCommon<TElement extends Element = Element, TDatasetElement extends Element = Element> {\n  type: string;\n  controller: DatasetController;\n  order: number;\n\n  label: string;\n  index: number;\n  visible: boolean;\n\n  stack: number;\n\n  indexAxis: 'x' | 'y';\n\n  data: TElement[];\n  dataset?: TDatasetElement;\n\n  hidden: boolean;\n\n  xAxisID?: string;\n  yAxisID?: string;\n  rAxisID?: string;\n  iAxisID: string;\n  vAxisID: string;\n\n  xScale?: Scale;\n  yScale?: Scale;\n  rScale?: Scale;\n  iScale?: Scale;\n  vScale?: Scale;\n\n  _sorted: boolean;\n  _stacked: boolean | 'single';\n  _parsed: unknown[];\n}\n\nexport type ChartMeta<\n  TType extends ChartType = ChartType,\n  TElement extends Element = Element,\n  TDatasetElement extends Element = Element,\n> = DeepPartial<\n{ [key in ChartType]: ChartTypeRegistry[key]['metaExtensions'] }[TType]\n> & ChartMetaCommon<TElement, TDatasetElement>;\n\nexport interface ActiveDataPoint {\n  datasetIndex: number;\n  index: number;\n}\n\nexport interface ActiveElement extends ActiveDataPoint {\n  element: Element;\n}\n\nexport declare class Chart<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown\n> {\n  readonly platform: BasePlatform;\n  readonly id: string;\n  readonly canvas: HTMLCanvasElement;\n  readonly ctx: CanvasRenderingContext2D;\n  readonly config: ChartConfiguration<TType, TData, TLabel> | ChartConfigurationCustomTypesPerDataset<TType, TData, TLabel>;\n  readonly width: number;\n  readonly height: number;\n  readonly aspectRatio: number;\n  readonly boxes: LayoutItem[];\n  readonly currentDevicePixelRatio: number;\n  readonly chartArea: ChartArea;\n  readonly scales: { [key: string]: Scale };\n  readonly attached: boolean;\n\n  readonly legend?: LegendElement<TType>; // Only available if legend plugin is registered and enabled\n  readonly tooltip?: TooltipModel<TType>; // Only available if tooltip plugin is registered and enabled\n\n  data: ChartData<TType, TData, TLabel>;\n  options: ChartOptions<TType>;\n\n  constructor(item: ChartItem, config: ChartConfiguration<TType, TData, TLabel> | ChartConfigurationCustomTypesPerDataset<TType, TData, TLabel>);\n\n  clear(): this;\n  stop(): this;\n\n  resize(width?: number, height?: number): void;\n  ensureScalesHaveIDs(): void;\n  buildOrUpdateScales(): void;\n  buildOrUpdateControllers(): void;\n  reset(): void;\n  update(mode?: UpdateMode | ((ctx: { datasetIndex: number }) => UpdateMode)): void;\n  render(): void;\n  draw(): void;\n\n  isPointInArea(point: Point): boolean;\n  getElementsAtEventForMode(e: Event, mode: string, options: InteractionOptions, useFinalPosition: boolean): InteractionItem[];\n\n  getSortedVisibleDatasetMetas(): ChartMeta[];\n  getDatasetMeta(datasetIndex: number): ChartMeta;\n  getVisibleDatasetCount(): number;\n  isDatasetVisible(datasetIndex: number): boolean;\n  setDatasetVisibility(datasetIndex: number, visible: boolean): void;\n  toggleDataVisibility(index: number): void;\n  getDataVisibility(index: number): boolean;\n  hide(datasetIndex: number, dataIndex?: number): void;\n  show(datasetIndex: number, dataIndex?: number): void;\n\n  getActiveElements(): ActiveElement[];\n  setActiveElements(active: ActiveDataPoint[]): void;\n\n  destroy(): void;\n  toBase64Image(type?: string, quality?: unknown): string;\n  bindEvents(): void;\n  unbindEvents(): void;\n  updateHoverStyle(items: InteractionItem[], mode: 'dataset', enabled: boolean): void;\n\n  notifyPlugins(hook: string, args?: AnyObject): boolean | void;\n\n  isPluginEnabled(pluginId: string): boolean;\n\n  getContext(): { chart: Chart, type: string };\n\n  static readonly defaults: Defaults;\n  static readonly overrides: Overrides;\n  static readonly version: string;\n  static readonly instances: { [key: string]: Chart };\n  static readonly registry: Registry;\n  static getChart(key: string | CanvasRenderingContext2D | HTMLCanvasElement): Chart | undefined;\n  static register(...items: ChartComponentLike[]): void;\n  static unregister(...items: ChartComponentLike[]): void;\n}\n\nexport declare const registerables: readonly ChartComponentLike[];\n\nexport declare type ChartItem =\n  | string\n  | CanvasRenderingContext2D\n  | HTMLCanvasElement\n  | { canvas: HTMLCanvasElement }\n  | ArrayLike<CanvasRenderingContext2D | HTMLCanvasElement>;\n\nexport declare enum UpdateModeEnum {\n  resize = 'resize',\n  reset = 'reset',\n  none = 'none',\n  hide = 'hide',\n  show = 'show',\n  default = 'default',\n  active = 'active'\n}\n\nexport type UpdateMode = keyof typeof UpdateModeEnum;\n\nexport declare class DatasetController<\n  TType extends ChartType = ChartType,\n  TElement extends Element = Element,\n  TDatasetElement extends Element = Element,\n  TParsedData = ParsedDataType<TType>,\n> {\n  constructor(chart: Chart, datasetIndex: number);\n\n  readonly chart: Chart;\n  readonly index: number;\n  readonly _cachedMeta: ChartMeta<TType, TElement, TDatasetElement>;\n  enableOptionSharing: boolean;\n  // If true, the controller supports the decimation\n  // plugin. Defaults to `false` for all controllers\n  // except the LineController\n  supportsDecimation: boolean;\n\n  linkScales(): void;\n  getAllParsedValues(scale: Scale): number[];\n  protected getLabelAndValue(index: number): { label: string; value: string };\n  updateElements(elements: TElement[], start: number, count: number, mode: UpdateMode): void;\n  update(mode: UpdateMode): void;\n  updateIndex(datasetIndex: number): void;\n  protected getMaxOverflow(): boolean | number;\n  draw(): void;\n  reset(): void;\n  getDataset(): ChartDataset;\n  getMeta(): ChartMeta<TType, TElement, TDatasetElement>;\n  getScaleForId(scaleID: string): Scale | undefined;\n  configure(): void;\n  initialize(): void;\n  addElements(): void;\n  buildOrUpdateElements(resetNewElements?: boolean): void;\n\n  getStyle(index: number, active: boolean): AnyObject;\n  protected resolveDatasetElementOptions(mode: UpdateMode): AnyObject;\n  protected resolveDataElementOptions(index: number, mode: UpdateMode): AnyObject;\n  /**\n   * Utility for checking if the options are shared and should be animated separately.\n   * @protected\n   */\n  protected getSharedOptions(options: AnyObject): undefined | AnyObject;\n  /**\n   * Utility for determining if `options` should be included in the updated properties\n   * @protected\n   */\n  protected includeOptions(mode: UpdateMode, sharedOptions: AnyObject): boolean;\n  /**\n   * Utility for updating an element with new properties, using animations when appropriate.\n   * @protected\n   */\n\n  protected updateElement(element: TElement | TDatasetElement, index: number | undefined, properties: AnyObject, mode: UpdateMode): void;\n  /**\n   * Utility to animate the shared options, that are potentially affecting multiple elements.\n   * @protected\n   */\n\n  protected updateSharedOptions(sharedOptions: AnyObject, mode: UpdateMode, newOptions: AnyObject): void;\n  removeHoverStyle(element: TElement, datasetIndex: number, index: number): void;\n  setHoverStyle(element: TElement, datasetIndex: number, index: number): void;\n\n  parse(start: number, count: number): void;\n  protected parsePrimitiveData(meta: ChartMeta<TType, TElement, TDatasetElement>, data: AnyObject[], start: number, count: number): AnyObject[];\n  protected parseArrayData(meta: ChartMeta<TType, TElement, TDatasetElement>, data: AnyObject[], start: number, count: number): AnyObject[];\n  protected parseObjectData(meta: ChartMeta<TType, TElement, TDatasetElement>, data: AnyObject[], start: number, count: number): AnyObject[];\n  protected getParsed(index: number): TParsedData;\n  protected applyStack(scale: Scale, parsed: unknown[]): number;\n  protected updateRangeFromParsed(\n    range: { min: number; max: number },\n    scale: Scale,\n    parsed: unknown[],\n    stack: boolean | string\n  ): void;\n  protected getMinMax(scale: Scale, canStack?: boolean): { min: number; max: number };\n}\n\nexport interface DatasetControllerChartComponent extends ChartComponent {\n  defaults: {\n    datasetElementType?: string | null | false;\n    dataElementType?: string | null | false;\n  };\n}\n\nexport interface Defaults extends CoreChartOptions<ChartType>, ElementChartOptions<ChartType>, PluginChartOptions<ChartType> {\n\n  scale: ScaleOptionsByType;\n  scales: {\n    [key in ScaleType]: ScaleOptionsByType<key>;\n  };\n\n  set(values: AnyObject): AnyObject;\n  set(scope: string, values: AnyObject): AnyObject;\n  get(scope: string): AnyObject;\n\n  describe(scope: string, values: AnyObject): AnyObject;\n  override(scope: string, values: AnyObject): AnyObject;\n\n  /**\n   * Routes the named defaults to fallback to another scope/name.\n   * This routing is useful when those target values, like defaults.color, are changed runtime.\n   * If the values would be copied, the runtime change would not take effect. By routing, the\n   * fallback is evaluated at each access, so its always up to date.\n   *\n   * Example:\n   *\n   *   defaults.route('elements.arc', 'backgroundColor', '', 'color')\n   *    - reads the backgroundColor from defaults.color when undefined locally\n   *\n   * @param scope Scope this route applies to.\n   * @param name Property name that should be routed to different namespace when not defined here.\n   * @param targetScope The namespace where those properties should be routed to.\n   * Empty string ('') is the root of defaults.\n   * @param targetName The target name in the target scope the property should be routed to.\n   */\n  route(scope: string, name: string, targetScope: string, targetName: string): void;\n}\n\nexport type Overrides = {\n  [key in ChartType]:\n  CoreChartOptions<key> &\n  ElementChartOptions<key> &\n  PluginChartOptions<key> &\n  DatasetChartOptions<ChartType> &\n  ScaleChartOptions<key> &\n  ChartTypeRegistry[key]['chartOptions'];\n}\n\nexport declare const defaults: Defaults;\nexport interface InteractionOptions {\n  axis?: string;\n  intersect?: boolean;\n  includeInvisible?: boolean;\n}\n\nexport interface InteractionItem {\n  element: Element;\n  datasetIndex: number;\n  index: number;\n}\n\nexport type InteractionModeFunction = (\n  chart: Chart,\n  e: ChartEvent,\n  options: InteractionOptions,\n  useFinalPosition?: boolean\n) => InteractionItem[];\n\nexport interface InteractionModeMap {\n  /**\n   * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n   * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n   */\n  index: InteractionModeFunction;\n\n  /**\n   * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n   * If the options.intersect is false, we find the nearest item and return the items in that dataset\n   */\n  dataset: InteractionModeFunction;\n  /**\n   * Point mode returns all elements that hit test based on the event position\n   * of the event\n   */\n  point: InteractionModeFunction;\n  /**\n   * nearest mode returns the element closest to the point\n   */\n  nearest: InteractionModeFunction;\n  /**\n   * x mode returns the elements that hit-test at the current x coordinate\n   */\n  x: InteractionModeFunction;\n  /**\n   * y mode returns the elements that hit-test at the current y coordinate\n   */\n  y: InteractionModeFunction;\n}\n\nexport type InteractionMode = keyof InteractionModeMap;\n\nexport declare const Interaction: {\n  modes: InteractionModeMap;\n\n  /**\n   * Helper function to select candidate elements for interaction\n   */\n  evaluateInteractionItems(\n    chart: Chart,\n    axis: InteractionAxis,\n    position: Point,\n    handler: (element: Element & VisualElement, datasetIndex: number, index: number) => void,\n    intersect?: boolean\n  ): InteractionItem[];\n};\n\nexport declare const layouts: {\n  /**\n   * Register a box to a chart.\n   * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n   * @param {Chart} chart - the chart to use\n   * @param {LayoutItem} item - the item to add to be laid out\n   */\n  addBox(chart: Chart, item: LayoutItem): void;\n\n  /**\n   * Remove a layoutItem from a chart\n   * @param {Chart} chart - the chart to remove the box from\n   * @param {LayoutItem} layoutItem - the item to remove from the layout\n   */\n  removeBox(chart: Chart, layoutItem: LayoutItem): void;\n\n  /**\n   * Sets (or updates) options on the given `item`.\n   * @param {Chart} chart - the chart in which the item lives (or will be added to)\n   * @param {LayoutItem} item - the item to configure with the given options\n   * @param options - the new item options.\n   */\n  configure(\n    chart: Chart,\n    item: LayoutItem,\n    options: { fullSize?: number; position?: LayoutPosition; weight?: number }\n  ): void;\n\n  /**\n   * Fits boxes of the given chart into the given size by having each box measure itself\n   * then running a fitting algorithm\n   * @param {Chart} chart - the chart\n   * @param {number} width - the width to fit into\n   * @param {number} height - the height to fit into\n   */\n  update(chart: Chart, width: number, height: number): void;\n};\n\nexport interface Plugin<TType extends ChartType = ChartType, O = AnyObject> extends ExtendedPlugin<TType, O> {\n  id: string;\n\n  /**\n   * The events option defines the browser events that the plugin should listen.\n   * @default ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove']\n   */\n  events?: (keyof HTMLElementEventMap)[]\n\n  /**\n   * @desc Called when plugin is installed for this chart instance. This hook is also invoked for disabled plugins (options === false).\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   * @since 3.0.0\n   */\n  install?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * @desc Called when a plugin is starting. This happens when chart is created or plugin is enabled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   * @since 3.0.0\n   */\n  start?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * @desc Called when a plugin stopping. This happens when chart is destroyed or plugin is disabled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   * @since 3.0.0\n   */\n  stop?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * @desc Called before initializing `chart`.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   */\n  beforeInit?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * @desc Called after `chart` has been initialized and before the first update.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   */\n  afterInit?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * @desc Called before updating `chart`. If any plugin returns `false`, the update\n   * is cancelled (and thus subsequent render(s)) until another `update` is triggered.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {UpdateMode} args.mode - The update mode\n   * @param {object} options - The plugin options.\n   * @returns {boolean} `false` to cancel the chart update.\n   */\n  beforeUpdate?(chart: Chart<TType>, args: { mode: UpdateMode, cancelable: true }, options: O): boolean | void;\n  /**\n   * @desc Called after `chart` has been updated and before rendering. Note that this\n   * hook will not be called if the chart update has been previously cancelled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {UpdateMode} args.mode - The update mode\n   * @param {object} options - The plugin options.\n   */\n  afterUpdate?(chart: Chart<TType>, args: { mode: UpdateMode }, options: O): void;\n  /**\n   * @desc Called during the update process, before any chart elements have been created.\n   * This can be used for data decimation by changing the data array inside a dataset.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   */\n  beforeElementsUpdate?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * @desc Called during chart reset\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   * @since version 3.0.0\n   */\n  reset?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * @desc Called before updating the `chart` datasets. If any plugin returns `false`,\n   * the datasets update is cancelled until another `update` is triggered.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {UpdateMode} args.mode - The update mode.\n   * @param {object} options - The plugin options.\n   * @returns {boolean} false to cancel the datasets update.\n   * @since version 2.1.5\n   */\n  beforeDatasetsUpdate?(chart: Chart<TType>, args: { mode: UpdateMode }, options: O): boolean | void;\n  /**\n   * @desc Called after the `chart` datasets have been updated. Note that this hook\n   * will not be called if the datasets update has been previously cancelled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {UpdateMode} args.mode - The update mode.\n   * @param {object} options - The plugin options.\n   * @since version 2.1.5\n   */\n  afterDatasetsUpdate?(chart: Chart<TType>, args: { mode: UpdateMode, cancelable: true }, options: O): void;\n  /**\n   * @desc Called before updating the `chart` dataset at the given `args.index`. If any plugin\n   * returns `false`, the datasets update is cancelled until another `update` is triggered.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {number} args.index - The dataset index.\n   * @param {object} args.meta - The dataset metadata.\n   * @param {UpdateMode} args.mode - The update mode.\n   * @param {object} options - The plugin options.\n   * @returns {boolean} `false` to cancel the chart datasets drawing.\n   */\n  beforeDatasetUpdate?(chart: Chart<TType>, args: { index: number; meta: ChartMeta, mode: UpdateMode, cancelable: true }, options: O): boolean | void;\n  /**\n   * @desc Called after the `chart` datasets at the given `args.index` has been updated. Note\n   * that this hook will not be called if the datasets update has been previously cancelled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {number} args.index - The dataset index.\n   * @param {object} args.meta - The dataset metadata.\n   * @param {UpdateMode} args.mode - The update mode.\n   * @param {object} options - The plugin options.\n   */\n  afterDatasetUpdate?(chart: Chart<TType>, args: { index: number; meta: ChartMeta, mode: UpdateMode, cancelable: false }, options: O): void;\n  /**\n   * @desc Called before laying out `chart`. If any plugin returns `false`,\n   * the layout update is cancelled until another `update` is triggered.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   * @returns {boolean} `false` to cancel the chart layout.\n   */\n  beforeLayout?(chart: Chart<TType>, args: { cancelable: true }, options: O): boolean | void;\n  /**\n   * @desc Called before scale data limits are calculated. This hook is called separately for each scale in the chart.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {Scale} args.scale - The scale.\n   * @param {object} options - The plugin options.\n   */\n  beforeDataLimits?(chart: Chart<TType>, args: { scale: Scale }, options: O): void;\n  /**\n   * @desc Called after scale data limits are calculated. This hook is called separately for each scale in the chart.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {Scale} args.scale - The scale.\n   * @param {object} options - The plugin options.\n   */\n  afterDataLimits?(chart: Chart<TType>, args: { scale: Scale }, options: O): void;\n  /**\n   * @desc Called before scale builds its ticks. This hook is called separately for each scale in the chart.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {Scale} args.scale - The scale.\n   * @param {object} options - The plugin options.\n   */\n  beforeBuildTicks?(chart: Chart<TType>, args: { scale: Scale }, options: O): void;\n  /**\n   * @desc Called after scale has build its ticks. This hook is called separately for each scale in the chart.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {Scale} args.scale - The scale.\n   * @param {object} options - The plugin options.\n   */\n  afterBuildTicks?(chart: Chart<TType>, args: { scale: Scale }, options: O): void;\n  /**\n   * @desc Called after the `chart` has been laid out. Note that this hook will not\n   * be called if the layout update has been previously cancelled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   */\n  afterLayout?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * @desc Called before rendering `chart`. If any plugin returns `false`,\n   * the rendering is cancelled until another `render` is triggered.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   * @returns {boolean} `false` to cancel the chart rendering.\n   */\n  beforeRender?(chart: Chart<TType>, args: { cancelable: true }, options: O): boolean | void;\n  /**\n   * @desc Called after the `chart` has been fully rendered (and animation completed). Note\n   * that this hook will not be called if the rendering has been previously cancelled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   */\n  afterRender?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * @desc Called before drawing `chart` at every animation frame. If any plugin returns `false`,\n   * the frame drawing is cancelled untilanother `render` is triggered.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   * @returns {boolean} `false` to cancel the chart drawing.\n   */\n  beforeDraw?(chart: Chart<TType>, args: { cancelable: true }, options: O): boolean | void;\n  /**\n   * @desc Called after the `chart` has been drawn. Note that this hook will not be called\n   * if the drawing has been previously cancelled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   */\n  afterDraw?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * @desc Called before drawing the `chart` datasets. If any plugin returns `false`,\n   * the datasets drawing is cancelled until another `render` is triggered.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   * @returns {boolean} `false` to cancel the chart datasets drawing.\n   */\n  beforeDatasetsDraw?(chart: Chart<TType>, args: { cancelable: true }, options: O): boolean | void;\n  /**\n   * @desc Called after the `chart` datasets have been drawn. Note that this hook\n   * will not be called if the datasets drawing has been previously cancelled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   */\n  afterDatasetsDraw?(chart: Chart<TType>, args: EmptyObject, options: O, cancelable: false): void;\n  /**\n   * @desc Called before drawing the `chart` dataset at the given `args.index` (datasets\n   * are drawn in the reverse order). If any plugin returns `false`, the datasets drawing\n   * is cancelled until another `render` is triggered.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {number} args.index - The dataset index.\n   * @param {object} args.meta - The dataset metadata.\n   * @param {object} options - The plugin options.\n   * @returns {boolean} `false` to cancel the chart datasets drawing.\n   */\n  beforeDatasetDraw?(chart: Chart<TType>, args: { index: number; meta: ChartMeta }, options: O): boolean | void;\n  /**\n   * @desc Called after the `chart` datasets at the given `args.index` have been drawn\n   * (datasets are drawn in the reverse order). Note that this hook will not be called\n   * if the datasets drawing has been previously cancelled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {number} args.index - The dataset index.\n   * @param {object} args.meta - The dataset metadata.\n   * @param {object} options - The plugin options.\n   */\n  afterDatasetDraw?(chart: Chart<TType>, args: { index: number; meta: ChartMeta }, options: O): void;\n  /**\n   * @desc Called before processing the specified `event`. If any plugin returns `false`,\n   * the event will be discarded.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {ChartEvent} args.event - The event object.\n   * @param {boolean} args.replay - True if this event is replayed from `Chart.update`\n   * @param {boolean} args.inChartArea - The event position is inside chartArea\n   * @param {object} options - The plugin options.\n   */\n  beforeEvent?(chart: Chart<TType>, args: { event: ChartEvent, replay: boolean, cancelable: true, inChartArea: boolean }, options: O): boolean | void;\n  /**\n   * @desc Called after the `event` has been consumed. Note that this hook\n   * will not be called if the `event` has been previously discarded.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {ChartEvent} args.event - The event object.\n   * @param {boolean} args.replay - True if this event is replayed from `Chart.update`\n   * @param {boolean} args.inChartArea - The event position is inside chartArea\n   * @param {boolean} [args.changed] - Set to true if the plugin needs a render. Should only be changed to true, because this args object is passed through all plugins.\n   * @param {object} options - The plugin options.\n   */\n  afterEvent?(chart: Chart<TType>, args: { event: ChartEvent, replay: boolean, changed?: boolean, cancelable: false, inChartArea: boolean }, options: O): void;\n  /**\n   * @desc Called after the chart as been resized.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {number} args.size - The new canvas display size (eq. canvas.style width & height).\n   * @param {object} options - The plugin options.\n   */\n  resize?(chart: Chart<TType>, args: { size: { width: number, height: number } }, options: O): void;\n  /**\n   * Called before the chart is being destroyed.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   */\n  beforeDestroy?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * Called after the chart has been destroyed.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   */\n  afterDestroy?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n  /**\n   * Called after chart is destroyed on all plugins that were installed for that chart. This hook is also invoked for disabled plugins (options === false).\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {object} options - The plugin options.\n   * @since 3.0.0\n   */\n  uninstall?(chart: Chart<TType>, args: EmptyObject, options: O): void;\n\n  /**\n   * Default options used in the plugin\n   */\n  defaults?: Partial<O>;\n}\n\nexport declare type ChartComponentLike = ChartComponent | ChartComponent[] | { [key: string]: ChartComponent } | Plugin | Plugin[];\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport interface Registry {\n  readonly controllers: TypedRegistry<DatasetController>;\n  readonly elements: TypedRegistry<Element>;\n  readonly plugins: TypedRegistry<Plugin>;\n  readonly scales: TypedRegistry<Scale>;\n\n  add(...args: ChartComponentLike[]): void;\n  remove(...args: ChartComponentLike[]): void;\n\n  addControllers(...args: ChartComponentLike[]): void;\n  addElements(...args: ChartComponentLike[]): void;\n  addPlugins(...args: ChartComponentLike[]): void;\n  addScales(...args: ChartComponentLike[]): void;\n\n  getController(id: string): DatasetController | undefined;\n  getElement(id: string): Element | undefined;\n  getPlugin(id: string): Plugin | undefined;\n  getScale(id: string): Scale | undefined;\n}\n\nexport declare const registry: Registry;\n\nexport interface Tick {\n  value: number;\n  label?: string | string[];\n  major?: boolean;\n}\n\nexport interface CoreScaleOptions {\n  /**\n   * Controls the axis global visibility (visible when true, hidden when false). When display: 'auto', the axis is visible only if at least one associated dataset is visible.\n   * @default true\n   */\n  display: boolean | 'auto';\n  /**\n   * Align pixel values to device pixels\n   */\n  alignToPixels: boolean;\n  /**\n   * Background color of the scale area.\n   */\n  backgroundColor: Color;\n  /**\n   * Reverse the scale.\n   * @default false\n   */\n  reverse: boolean;\n  /**\n   * Clip the dataset drawing against the size of the scale instead of chart area.\n   * @default true\n   */\n  clip: boolean;\n  /**\n   * The weight used to sort the axis. Higher weights are further away from the chart area.\n   * @default true\n   */\n  weight: number;\n  /**\n   * User defined minimum value for the scale, overrides minimum value from data.\n   */\n  min: unknown;\n  /**\n   * User defined maximum value for the scale, overrides maximum value from data.\n   */\n  max: unknown;\n  /**\n   * Adjustment used when calculating the maximum data value.\n   */\n  suggestedMin: unknown;\n  /**\n   * Adjustment used when calculating the minimum data value.\n   */\n  suggestedMax: unknown;\n  /**\n   * Callback called before the update process starts.\n   */\n  beforeUpdate(axis: Scale): void;\n  /**\n   * Callback that runs before dimensions are set.\n   */\n  beforeSetDimensions(axis: Scale): void;\n  /**\n   * Callback that runs after dimensions are set.\n   */\n  afterSetDimensions(axis: Scale): void;\n  /**\n   * Callback that runs before data limits are determined.\n   */\n  beforeDataLimits(axis: Scale): void;\n  /**\n   * Callback that runs after data limits are determined.\n   */\n  afterDataLimits(axis: Scale): void;\n  /**\n   * Callback that runs before ticks are created.\n   */\n  beforeBuildTicks(axis: Scale): void;\n  /**\n   * Callback that runs after ticks are created. Useful for filtering ticks.\n   */\n  afterBuildTicks(axis: Scale): void;\n  /**\n   * Callback that runs before ticks are converted into strings.\n   */\n  beforeTickToLabelConversion(axis: Scale): void;\n  /**\n   * Callback that runs after ticks are converted into strings.\n   */\n  afterTickToLabelConversion(axis: Scale): void;\n  /**\n   * Callback that runs before tick rotation is determined.\n   */\n  beforeCalculateLabelRotation(axis: Scale): void;\n  /**\n   * Callback that runs after tick rotation is determined.\n   */\n  afterCalculateLabelRotation(axis: Scale): void;\n  /**\n   * Callback that runs before the scale fits to the canvas.\n   */\n  beforeFit(axis: Scale): void;\n  /**\n   * Callback that runs after the scale fits to the canvas.\n   */\n  afterFit(axis: Scale): void;\n  /**\n   * Callback that runs at the end of the update process.\n   */\n  afterUpdate(axis: Scale): void;\n}\n\nexport interface Scale<O extends CoreScaleOptions = CoreScaleOptions> extends Element<unknown, O>, LayoutItem {\n  readonly id: string;\n  readonly type: string;\n  readonly ctx: CanvasRenderingContext2D;\n  readonly chart: Chart;\n\n  maxWidth: number;\n  maxHeight: number;\n\n  paddingTop: number;\n  paddingBottom: number;\n  paddingLeft: number;\n  paddingRight: number;\n\n  axis: string;\n  labelRotation: number;\n  min: number;\n  max: number;\n  ticks: Tick[];\n  getMatchingVisibleMetas(type?: string): ChartMeta[];\n\n  drawTitle(chartArea: ChartArea): void;\n  drawLabels(chartArea: ChartArea): void;\n  drawGrid(chartArea: ChartArea): void;\n\n  /**\n   * @param {number} pixel\n   * @return {number}\n   */\n  getDecimalForPixel(pixel: number): number;\n  /**\n   * Utility for getting the pixel location of a percentage of scale\n   * The coordinate (0, 0) is at the upper-left corner of the canvas\n   * @param {number} decimal\n   * @return {number}\n   */\n  getPixelForDecimal(decimal: number): number;\n  /**\n   * Returns the location of the tick at the given index\n   * The coordinate (0, 0) is at the upper-left corner of the canvas\n   * @param {number} index\n   * @return {number}\n   */\n  getPixelForTick(index: number): number;\n  /**\n   * Used to get the label to display in the tooltip for the given value\n   * @param {*} value\n   * @return {string}\n   */\n  getLabelForValue(value: number): string;\n\n  /**\n   * Returns the grid line width at given value\n   */\n  getLineWidthForValue(value: number): number;\n\n  /**\n   * Returns the location of the given data point. Value can either be an index or a numerical value\n   * The coordinate (0, 0) is at the upper-left corner of the canvas\n   * @param {*} value\n   * @param {number} [index]\n   * @return {number}\n   */\n  getPixelForValue(value: number, index?: number): number;\n\n  /**\n   * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n   * The coordinate (0, 0) is at the upper-left corner of the canvas\n   * @param {number} pixel\n   * @return {*}\n   */\n  getValueForPixel(pixel: number): number | undefined;\n\n  getBaseValue(): number;\n  /**\n   * Returns the pixel for the minimum chart value\n   * The coordinate (0, 0) is at the upper-left corner of the canvas\n   * @return {number}\n   */\n  getBasePixel(): number;\n\n  init(options: O): void;\n  parse(raw: unknown, index?: number): unknown;\n  getUserBounds(): { min: number; max: number; minDefined: boolean; maxDefined: boolean };\n  getMinMax(canStack: boolean): { min: number; max: number };\n  getTicks(): Tick[];\n  getLabels(): string[];\n  getLabelItems(chartArea?: ChartArea): LabelItem[];\n  beforeUpdate(): void;\n  configure(): void;\n  afterUpdate(): void;\n  beforeSetDimensions(): void;\n  setDimensions(): void;\n  afterSetDimensions(): void;\n  beforeDataLimits(): void;\n  determineDataLimits(): void;\n  afterDataLimits(): void;\n  beforeBuildTicks(): void;\n  buildTicks(): Tick[];\n  afterBuildTicks(): void;\n  beforeTickToLabelConversion(): void;\n  generateTickLabels(ticks: Tick[]): void;\n  afterTickToLabelConversion(): void;\n  beforeCalculateLabelRotation(): void;\n  calculateLabelRotation(): void;\n  afterCalculateLabelRotation(): void;\n  beforeFit(): void;\n  fit(): void;\n  afterFit(): void;\n\n  isFullSize(): boolean;\n}\nexport declare class Scale {\n  constructor(cfg: {id: string, type: string, ctx: CanvasRenderingContext2D, chart: Chart});\n}\n\nexport interface ScriptableScaleContext {\n  chart: Chart;\n  scale: Scale;\n  index: number;\n  tick: Tick;\n}\n\nexport interface ScriptableScalePointLabelContext {\n  chart: Chart;\n  scale: Scale;\n  index: number;\n  label: string;\n  type: string;\n}\n\nexport interface RenderTextOpts {\n  /**\n   * The fill color of the text. If unset, the existing\n   * fillStyle property of the canvas is unchanged.\n   */\n  color?: Color;\n\n  /**\n   * The width of the strikethrough / underline\n   * @default 2\n   */\n  decorationWidth?: number;\n\n  /**\n   * The max width of the text in pixels\n   */\n  maxWidth?: number;\n\n  /**\n   * A rotation to be applied to the canvas\n   * This is applied after the translation is applied\n   */\n  rotation?: number;\n\n  /**\n   * Apply a strikethrough effect to the text\n   */\n  strikethrough?: boolean;\n\n  /**\n   * The color of the text stroke. If unset, the existing\n   * strokeStyle property of the context is unchanged\n   */\n  strokeColor?: Color;\n\n  /**\n   * The text stroke width. If unset, the existing\n   * lineWidth property of the context is unchanged\n   */\n  strokeWidth?: number;\n\n  /**\n   * The text alignment to use. If unset, the existing\n   * textAlign property of the context is unchanged\n   */\n  textAlign?: CanvasTextAlign;\n\n  /**\n   * The text baseline to use. If unset, the existing\n   * textBaseline property of the context is unchanged\n   */\n  textBaseline?: CanvasTextBaseline;\n\n  /**\n   * If specified, a translation to apply to the context\n   */\n  translation?: [number, number];\n\n  /**\n   * Underline the text\n   */\n  underline?: boolean;\n\n  /**\n   * Dimensions for drawing the label backdrop\n   */\n  backdrop?: BackdropOptions;\n}\n\nexport interface BackdropOptions {\n  /**\n   * Left position of backdrop as pixel\n   */\n  left: number;\n\n  /**\n   * Top position of backdrop as pixel\n   */\n  top: number;\n\n  /**\n   * Width of backdrop in pixels\n   */\n  width: number;\n\n  /**\n   * Height of backdrop in pixels\n   */\n  height: number;\n\n  /**\n   * Color of label backdrops.\n   */\n  color: Scriptable<Color, ScriptableScaleContext>;\n}\n\nexport interface LabelItem {\n  label: string | string[];\n  font: CanvasFontSpec;\n  textOffset: number;\n  options: RenderTextOpts;\n}\n\nexport declare const Ticks: {\n  formatters: {\n    /**\n     * Formatter for value labels\n     * @param value the value to display\n     * @return {string|string[]} the label to display\n     */\n    values(value: unknown): string | string[];\n    /**\n     * Formatter for numeric ticks\n     * @param tickValue the value to be formatted\n     * @param index the position of the tickValue parameter in the ticks array\n     * @param ticks the list of ticks being converted\n     * @return string representation of the tickValue parameter\n     */\n    numeric(tickValue: number, index: number, ticks: { value: number }[]): string;\n    /**\n     * Formatter for logarithmic ticks\n     * @param tickValue the value to be formatted\n     * @param index the position of the tickValue parameter in the ticks array\n     * @param ticks the list of ticks being converted\n     * @return string representation of the tickValue parameter\n     */\n    logarithmic(tickValue: number, index: number, ticks: { value: number }[]): string;\n  };\n};\n\nexport interface TypedRegistry<T> {\n  /**\n   * @param {ChartComponent} item\n   * @returns {string} The scope where items defaults were registered to.\n   */\n  register(item: ChartComponent): string;\n  get(id: string): T | undefined;\n  unregister(item: ChartComponent): void;\n}\n\nexport interface ChartEvent {\n  type:\n  | 'contextmenu'\n  | 'mouseenter'\n  | 'mousedown'\n  | 'mousemove'\n  | 'mouseup'\n  | 'mouseout'\n  | 'click'\n  | 'dblclick'\n  | 'keydown'\n  | 'keypress'\n  | 'keyup'\n  | 'resize';\n  native: Event | null;\n  x: number | null;\n  y: number | null;\n}\nexport interface ChartComponent {\n  id: string;\n  defaults?: AnyObject;\n  defaultRoutes?: { [property: string]: string };\n\n  beforeRegister?(): void;\n  afterRegister?(): void;\n  beforeUnregister?(): void;\n  afterUnregister?(): void;\n}\n\nexport type InteractionAxis = 'x' | 'y' | 'xy' | 'r';\n\nexport interface CoreInteractionOptions {\n  /**\n   * Sets which elements appear in the tooltip. See Interaction Modes for details.\n   * @default 'nearest'\n   */\n  mode: InteractionMode;\n  /**\n   * if true, the hover mode only applies when the mouse position intersects an item on the chart.\n   * @default true\n   */\n  intersect: boolean;\n\n  /**\n   * Defines which directions are used in calculating distances. Defaults to 'x' for 'index' mode and 'xy' in dataset and 'nearest' modes.\n   */\n  axis: InteractionAxis;\n\n  /**\n   * if true, the invisible points that are outside of the chart area will also be included when evaluating interactions.\n   * @default false\n   */\n  includeInvisible: boolean;\n}\n\nexport interface CoreChartOptions<TType extends ChartType> extends ParsingOptions, AnimationOptions<TType> {\n\n  datasets: {\n    [key in ChartType]: ChartTypeRegistry[key]['datasetOptions']\n  }\n\n  /**\n   * The base axis of the chart. 'x' for vertical charts and 'y' for horizontal charts.\n   * @default 'x'\n   */\n  indexAxis: 'x' | 'y';\n\n  /**\n   * How to clip relative to chartArea. Positive value allows overflow, negative value clips that many pixels inside chartArea. 0 = clip at chartArea. Clipping can also be configured per side: `clip: {left: 5, top: false, right: -2, bottom: 0}`\n   */\n  clip: number | ChartArea | false;\n\n  /**\n   * base color\n   * @see Defaults.color\n   */\n  color: Scriptable<Color, ScriptableContext<TType>>;\n  /**\n   * base background color\n   * @see Defaults.backgroundColor\n   */\n  backgroundColor: Scriptable<Color, ScriptableContext<TType>>;\n  /**\n   * base border color\n   * @see Defaults.borderColor\n   */\n  borderColor: Scriptable<Color, ScriptableContext<TType>>;\n  /**\n   * base font\n   * @see Defaults.font\n   */\n  font: Partial<FontSpec>;\n  /**\n   * Resizes the chart canvas when its container does (important note...).\n   * @default true\n   */\n  responsive: boolean;\n  /**\n   * Maintain the original canvas aspect ratio (width / height) when resizing. For this option to work properly the chart must be in its own dedicated container.\n   * @default true\n   */\n  maintainAspectRatio: boolean;\n  /**\n   * Delay the resize update by give amount of milliseconds. This can ease the resize process by debouncing update of the elements.\n   * @default 0\n   */\n  resizeDelay: number;\n\n  /**\n   * Canvas aspect ratio (i.e. width / height, a value of 1 representing a square canvas). Note that this option is ignored if the height is explicitly defined either as attribute or via the style.\n   * @default 2\n   */\n  aspectRatio: number;\n\n  /**\n   * Locale used for number formatting (using `Intl.NumberFormat`).\n   * @default user's browser setting\n   */\n  locale: string;\n\n  /**\n   * Called when a resize occurs. Gets passed two arguments: the chart instance and the new size.\n   */\n  onResize(chart: Chart, size: { width: number; height: number }): void;\n\n  /**\n   * Override the window's default devicePixelRatio.\n   * @default window.devicePixelRatio\n   */\n  devicePixelRatio: number;\n\n  interaction: CoreInteractionOptions;\n\n  hover: CoreInteractionOptions;\n\n  /**\n   * The events option defines the browser events that the chart should listen to for tooltips and hovering.\n   * @default ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove']\n   */\n  events: (keyof HTMLElementEventMap)[]\n\n  /**\n   * Called when any of the events fire. Passed the event, an array of active elements (bars, points, etc), and the chart.\n   */\n  onHover(event: ChartEvent, elements: ActiveElement[], chart: Chart): void;\n\n  /**\n   * Called if the event is of type 'mouseup' or 'click'. Passed the event, an array of active elements, and the chart.\n   */\n  onClick(event: ChartEvent, elements: ActiveElement[], chart: Chart): void;\n\n  layout: Partial<{\n    autoPadding: boolean;\n    padding: Scriptable<Padding, ScriptableContext<TType>>;\n  }>;\n}\n\nexport type AnimationSpec<TType extends ChartType> = {\n  /**\n   * The number of milliseconds an animation takes.\n   * @default 1000\n   */\n  duration?: Scriptable<number, ScriptableContext<TType>>;\n  /**\n   * Easing function to use\n   * @default 'easeOutQuart'\n   */\n  easing?: Scriptable<EasingFunction, ScriptableContext<TType>>;\n\n  /**\n   * Delay before starting the animations.\n   * @default 0\n   */\n  delay?: Scriptable<number, ScriptableContext<TType>>;\n\n  /**\n   *   If set to true, the animations loop endlessly.\n   * @default false\n   */\n  loop?: Scriptable<boolean, ScriptableContext<TType>>;\n}\n\nexport type AnimationsSpec<TType extends ChartType> = {\n  [name: string]: false | AnimationSpec<TType> & {\n    properties: string[];\n\n    /**\n     * Type of property, determines the interpolator used. Possible values: 'number', 'color' and 'boolean'. Only really needed for 'color', because typeof does not get that right.\n     */\n    type: 'color' | 'number' | 'boolean';\n\n    fn: <T>(from: T, to: T, factor: number) => T;\n\n    /**\n     * Start value for the animation. Current value is used when undefined\n     */\n    from: Scriptable<Color | number | boolean, ScriptableContext<TType>>;\n    /**\n     *\n     */\n    to: Scriptable<Color | number | boolean, ScriptableContext<TType>>;\n  }\n}\n\nexport type TransitionSpec<TType extends ChartType> = {\n  animation: AnimationSpec<TType>;\n  animations: AnimationsSpec<TType>;\n}\n\nexport type TransitionsSpec<TType extends ChartType> = {\n  [mode: string]: TransitionSpec<TType>\n}\n\nexport type AnimationOptions<TType extends ChartType> = {\n  animation: false | AnimationSpec<TType> & {\n    /**\n     * Callback called on each step of an animation.\n     */\n    onProgress?: (this: Chart, event: AnimationEvent) => void;\n    /**\n     * Callback called when all animations are completed.\n     */\n    onComplete?: (this: Chart, event: AnimationEvent) => void;\n  };\n  animations: AnimationsSpec<TType>;\n  transitions: TransitionsSpec<TType>;\n};\n\nexport interface FontSpec {\n  /**\n   * Default font family for all text, follows CSS font-family options.\n   * @default \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\"\n   */\n  family: string;\n  /**\n   * Default font size (in px) for text. Does not apply to radialLinear scale point labels.\n   * @default 12\n   */\n  size: number;\n  /**\n   * Default font style. Does not apply to tooltip title or footer. Does not apply to chart title. Follows CSS font-style options (i.e. normal, italic, oblique, initial, inherit)\n   * @default 'normal'\n   */\n  style: 'normal' | 'italic' | 'oblique' | 'initial' | 'inherit';\n  /**\n   * Default font weight (boldness). (see MDN).\n   */\n  weight: 'normal' | 'bold' | 'lighter' | 'bolder' | number | null;\n  /**\n   * Height of an individual line of text (see MDN).\n   * @default 1.2\n   */\n  lineHeight: number | string;\n}\n\nexport interface CanvasFontSpec extends FontSpec {\n  string: string;\n}\n\nexport type TextAlign = 'left' | 'center' | 'right';\nexport type Align = 'start' | 'center' | 'end';\n\nexport interface VisualElement {\n  draw(ctx: CanvasRenderingContext2D, area?: ChartArea): void;\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean): boolean;\n  inXRange(mouseX: number, useFinalPosition?: boolean): boolean;\n  inYRange(mouseY: number, useFinalPosition?: boolean): boolean;\n  getCenterPoint(useFinalPosition?: boolean): Point;\n  getRange?(axis: 'x' | 'y'): number;\n}\n\nexport interface CommonElementOptions {\n  borderWidth: number;\n  borderColor: Color;\n  backgroundColor: Color;\n}\n\nexport interface CommonHoverOptions {\n  hoverBorderWidth: number;\n  hoverBorderColor: Color;\n  hoverBackgroundColor: Color;\n}\n\nexport interface Segment {\n  start: number;\n  end: number;\n  loop: boolean;\n}\n\nexport interface ArcBorderRadius {\n  outerStart: number;\n  outerEnd: number;\n  innerStart: number;\n  innerEnd: number;\n}\n\nexport interface ArcOptions extends CommonElementOptions {\n  /**\n   * Arc stroke alignment.\n   */\n  borderAlign: 'center' | 'inner';\n  /**\n   * Line dash. See MDN.\n   * @default []\n   */\n  borderDash: number[];\n  /**\n   * Line dash offset. See MDN.\n   * @default 0.0\n   */\n  borderDashOffset: number;\n  /**\n   * Line join style. See MDN. Default is 'round' when `borderAlign` is 'inner', else 'bevel'.\n   */\n  borderJoinStyle: CanvasLineJoin;\n\n  /**\n   * Sets the border radius for arcs\n   * @default 0\n   */\n  borderRadius: number | ArcBorderRadius;\n\n  /**\n   * Arc offset (in pixels).\n   */\n  offset: number;\n\n  /**\n   * If false, Arc will be flat.\n   * @default true\n   */\n  circular: boolean;\n\n  /**\n   * Spacing between arcs\n   */\n  spacing: number\n}\n\nexport interface ArcHoverOptions extends CommonHoverOptions {\n  hoverBorderDash: number[];\n  hoverBorderDashOffset: number;\n  hoverOffset: number;\n}\n\nexport interface LineProps {\n  points: Point[]\n}\n\nexport interface LineOptions extends CommonElementOptions {\n  /**\n   * Line cap style. See MDN.\n   * @default 'butt'\n   */\n  borderCapStyle: CanvasLineCap;\n  /**\n   * Line dash. See MDN.\n   * @default []\n   */\n  borderDash: number[];\n  /**\n   * Line dash offset. See MDN.\n   * @default 0.0\n   */\n  borderDashOffset: number;\n  /**\n   * Line join style. See MDN.\n   * @default 'miter'\n   */\n  borderJoinStyle: CanvasLineJoin;\n  /**\n   *   true to keep Bzier control inside the chart, false for no restriction.\n   * @default true\n   */\n  capBezierPoints: boolean;\n  /**\n   * Interpolation mode to apply.\n   * @default 'default'\n   */\n  cubicInterpolationMode: 'default' | 'monotone';\n  /**\n   * Bzier curve tension (0 for no Bzier curves).\n   * @default 0\n   */\n  tension: number;\n  /**\n   * true to show the line as a stepped line (tension will be ignored).\n   * @default false\n   */\n  stepped: 'before' | 'after' | 'middle' | boolean;\n  /**\n   * Both line and radar charts support a fill option on the dataset object which can be used to create area between two datasets or a dataset and a boundary, i.e. the scale origin, start or end\n   */\n  fill: FillTarget | ComplexFillTarget;\n  /**\n   * If true, lines will be drawn between points with no or null data. If false, points with NaN data will create a break in the line. Can also be a number specifying the maximum gap length to span. The unit of the value depends on the scale used.\n   */\n  spanGaps: boolean | number;\n\n  segment: {\n    backgroundColor: Scriptable<Color|undefined, ScriptableLineSegmentContext>,\n    borderColor: Scriptable<Color|undefined, ScriptableLineSegmentContext>,\n    borderCapStyle: Scriptable<CanvasLineCap|undefined, ScriptableLineSegmentContext>;\n    borderDash: Scriptable<number[]|undefined, ScriptableLineSegmentContext>;\n    borderDashOffset: Scriptable<number|undefined, ScriptableLineSegmentContext>;\n    borderJoinStyle: Scriptable<CanvasLineJoin|undefined, ScriptableLineSegmentContext>;\n    borderWidth: Scriptable<number|undefined, ScriptableLineSegmentContext>;\n  };\n}\n\nexport interface LineHoverOptions extends CommonHoverOptions {\n  hoverBorderCapStyle: CanvasLineCap;\n  hoverBorderDash: number[];\n  hoverBorderDashOffset: number;\n  hoverBorderJoinStyle: CanvasLineJoin;\n}\n\nexport interface LineElement<T extends LineProps = LineProps, O extends LineOptions = LineOptions>\n  extends Element<T, O>,\n  VisualElement {\n  updateControlPoints(chartArea: ChartArea, indexAxis?: 'x' | 'y'): void;\n  points: Point[];\n  readonly segments: Segment[];\n  first(): Point | false;\n  last(): Point | false;\n  interpolate(point: Point, property: 'x' | 'y'): undefined | Point | Point[];\n  pathSegment(ctx: CanvasRenderingContext2D, segment: Segment, params: AnyObject): undefined | boolean;\n  path(ctx: CanvasRenderingContext2D): boolean;\n}\n\nexport declare const LineElement: ChartComponent & {\n  prototype: LineElement;\n  new (cfg: AnyObject): LineElement;\n};\n\nexport type PointStyle =\n  | 'circle'\n  | 'cross'\n  | 'crossRot'\n  | 'dash'\n  | 'line'\n  | 'rect'\n  | 'rectRounded'\n  | 'rectRot'\n  | 'star'\n  | 'triangle'\n  | false\n  | HTMLImageElement\n  | HTMLCanvasElement;\n\nexport interface PointOptions extends CommonElementOptions {\n  /**\n   * Point radius\n   * @default 3\n   */\n  radius: number;\n  /**\n   * Extra radius added to point radius for hit detection.\n   * @default 1\n   */\n  hitRadius: number;\n  /**\n   * Point style\n   * @default 'circle;\n   */\n  pointStyle: PointStyle;\n  /**\n   * Point rotation (in degrees).\n   * @default 0\n   */\n  rotation: number;\n  /**\n   * Draw the active elements over the other elements of the dataset,\n   * @default true\n   */\n  drawActiveElementsOnTop: boolean;\n}\n\nexport interface PointHoverOptions extends CommonHoverOptions {\n  /**\n   * Point radius when hovered.\n   * @default 4\n   */\n  hoverRadius: number;\n}\n\nexport interface PointPrefixedOptions {\n  /**\n   * The fill color for points.\n   */\n  pointBackgroundColor: Color;\n  /**\n   * The border color for points.\n   */\n  pointBorderColor: Color;\n  /**\n   * The width of the point border in pixels.\n   */\n  pointBorderWidth: number;\n  /**\n   * The pixel size of the non-displayed point that reacts to mouse events.\n   */\n  pointHitRadius: number;\n  /**\n   * The radius of the point shape. If set to 0, the point is not rendered.\n   */\n  pointRadius: number;\n  /**\n   * The rotation of the point in degrees.\n   */\n  pointRotation: number;\n  /**\n   * Style of the point.\n   */\n  pointStyle: PointStyle;\n}\n\nexport interface PointPrefixedHoverOptions {\n  /**\n   * Point background color when hovered.\n   */\n  pointHoverBackgroundColor: Color;\n  /**\n   * Point border color when hovered.\n   */\n  pointHoverBorderColor: Color;\n  /**\n   * Border width of point when hovered.\n   */\n  pointHoverBorderWidth: number;\n  /**\n   * The radius of the point when hovered.\n   */\n  pointHoverRadius: number;\n}\n\nexport interface BarProps extends Point {\n  base: number;\n  horizontal: boolean;\n  width: number;\n  height: number;\n}\n\nexport interface BarOptions extends Omit<CommonElementOptions, 'borderWidth'> {\n  /**\n   * The base value for the bar in data units along the value axis.\n   */\n  base: number;\n\n  /**\n   * Skipped (excluded) border: 'start', 'end', 'left',  'right', 'bottom', 'top', 'middle', false (none) or true (all).\n   * @default 'start'\n   */\n  borderSkipped: 'start' | 'end' | 'left' | 'right' | 'bottom' | 'top' | 'middle' | boolean;\n\n  /**\n   * Border radius\n   * @default 0\n   */\n  borderRadius: number | BorderRadius;\n\n  /**\n   * Amount to inflate the rectangle(s). This can be used to hide artifacts between bars.\n   * Unit is pixels. 'auto' translates to 0.33 pixels when barPercentage * categoryPercentage is 1, else 0.\n   * @default 'auto'\n   */\n  inflateAmount: number | 'auto';\n\n  /**\n   * Width of the border, number for all sides, object to specify width for each side specifically\n   * @default 0\n   */\n  borderWidth: number | { top?: number, right?: number, bottom?: number, left?: number };\n}\n\nexport interface BorderRadius {\n  topLeft: number;\n  topRight: number;\n  bottomLeft: number;\n  bottomRight: number;\n}\n\nexport interface BarHoverOptions extends CommonHoverOptions {\n  hoverBorderRadius: number | BorderRadius;\n}\n\nexport interface BarElement<\n  T extends BarProps = BarProps,\n  O extends BarOptions = BarOptions\n> extends Element<T, O>, VisualElement {}\n\nexport declare const BarElement: ChartComponent & {\n  prototype: BarElement;\n  new (cfg: AnyObject): BarElement;\n};\n\nexport interface ElementOptionsByType<TType extends ChartType> {\n  arc: ScriptableAndArrayOptions<ArcOptions & ArcHoverOptions, ScriptableContext<TType>>;\n  bar: ScriptableAndArrayOptions<BarOptions & BarHoverOptions, ScriptableContext<TType>>;\n  line: ScriptableAndArrayOptions<LineOptions & LineHoverOptions, ScriptableContext<TType>>;\n  point: ScriptableAndArrayOptions<PointOptions & PointHoverOptions, ScriptableContext<TType>>;\n}\n\nexport type ElementChartOptions<TType extends ChartType = ChartType> = {\n  elements: ElementOptionsByType<TType>\n};\n\nexport declare class BasePlatform {\n  /**\n   * Called at chart construction time, returns a context2d instance implementing\n   * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n   * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\n   * @param options - The chart options\n   */\n  acquireContext(\n    canvas: HTMLCanvasElement,\n    options?: CanvasRenderingContext2DSettings\n  ): CanvasRenderingContext2D | null;\n  /**\n   * Called at chart destruction time, releases any resources associated to the context\n   * previously returned by the acquireContext() method.\n   * @param {CanvasRenderingContext2D} context - The context2d instance\n   * @returns {boolean} true if the method succeeded, else false\n   */\n  releaseContext(context: CanvasRenderingContext2D): boolean;\n  /**\n   * Registers the specified listener on the given chart.\n   * @param {Chart} chart - Chart from which to listen for event\n   * @param {string} type - The ({@link ChartEvent}) type to listen for\n   * @param listener - Receives a notification (an object that implements\n   * the {@link ChartEvent} interface) when an event of the specified type occurs.\n   */\n  addEventListener(chart: Chart, type: string, listener: (e: ChartEvent) => void): void;\n  /**\n   * Removes the specified listener previously registered with addEventListener.\n   * @param {Chart} chart - Chart from which to remove the listener\n   * @param {string} type - The ({@link ChartEvent}) type to remove\n   * @param listener - The listener function to remove from the event target.\n   */\n  removeEventListener(chart: Chart, type: string, listener: (e: ChartEvent) => void): void;\n  /**\n   * @returns {number} the current devicePixelRatio of the device this platform is connected to.\n   */\n  getDevicePixelRatio(): number;\n  /**\n   * @param {HTMLCanvasElement} canvas - The canvas for which to calculate the maximum size\n   * @param {number} [width] - Parent element's content width\n   * @param {number} [height] - Parent element's content height\n   * @param {number} [aspectRatio] - The aspect ratio to maintain\n   * @returns { width: number, height: number } the maximum size available.\n   */\n  getMaximumSize(canvas: HTMLCanvasElement, width?: number, height?: number, aspectRatio?: number): { width: number, height: number };\n  /**\n   * @param {HTMLCanvasElement} canvas\n   * @returns {boolean} true if the canvas is attached to the platform, false if not.\n   */\n  isAttached(canvas: HTMLCanvasElement): boolean;\n  /**\n   * Updates config with platform specific requirements\n   * @param {ChartConfiguration | ChartConfigurationCustomTypes} config\n   */\n  updateConfig(config: ChartConfiguration | ChartConfigurationCustomTypesPerDataset): void;\n}\n\nexport declare class BasicPlatform extends BasePlatform {}\nexport declare class DomPlatform extends BasePlatform {}\n\nexport declare const Decimation: Plugin;\n\nexport declare const enum DecimationAlgorithm {\n  lttb = 'lttb',\n  minmax = 'min-max',\n}\ninterface BaseDecimationOptions {\n  enabled: boolean;\n  threshold?: number;\n}\n\ninterface LttbDecimationOptions extends BaseDecimationOptions {\n  algorithm: DecimationAlgorithm.lttb | 'lttb';\n  samples?: number;\n}\n\ninterface MinMaxDecimationOptions extends BaseDecimationOptions {\n  algorithm: DecimationAlgorithm.minmax | 'min-max';\n}\n\nexport type DecimationOptions = LttbDecimationOptions | MinMaxDecimationOptions;\n\nexport declare const Filler: Plugin;\nexport interface FillerOptions {\n  drawTime: 'beforeDraw' | 'beforeDatasetDraw' | 'beforeDatasetsDraw';\n  propagate: boolean;\n}\n\nexport type FillTarget = number | string | { value: number } | 'start' | 'end' | 'origin' | 'stack' | 'shape' | boolean;\n\nexport interface ComplexFillTarget {\n  /**\n   * The accepted values are the same as the filling mode values, so you may use absolute and relative dataset indexes and/or boundaries.\n   */\n  target: FillTarget;\n  /**\n   * If no color is set, the default color will be the background color of the chart.\n   */\n  above: Color;\n  /**\n   * Same as the above.\n   */\n  below: Color;\n}\n\nexport interface FillerControllerDatasetOptions {\n  /**\n   * Both line and radar charts support a fill option on the dataset object which can be used to create area between two datasets or a dataset and a boundary, i.e. the scale origin, start or end\n   */\n  fill: FillTarget | ComplexFillTarget;\n}\n\nexport declare const Legend: Plugin;\n\nexport interface LegendItem {\n  /**\n   * Label that will be displayed\n   */\n  text: string;\n\n  /**\n   * Border radius of the legend box\n   * @since 3.1.0\n   */\n  borderRadius?: number | BorderRadius;\n\n  /**\n   * Index of the associated dataset\n   */\n  datasetIndex?: number;\n\n  /**\n   * Index the associated label in the labels array\n   */\n  index?: number\n\n  /**\n   * Fill style of the legend box\n   */\n  fillStyle?: Color;\n\n  /**\n   * Font color for the text\n   * Defaults to LegendOptions.labels.color\n   */\n  fontColor?: Color;\n\n  /**\n   * If true, this item represents a hidden dataset. Label will be rendered with a strike-through effect\n   */\n  hidden?: boolean;\n\n  /**\n   * For box border.\n   * @see https://developer.mozilla.org/en/docs/Web/API/CanvasRenderingContext2D/lineCap\n   */\n  lineCap?: CanvasLineCap;\n\n  /**\n   * For box border.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash\n   */\n  lineDash?: number[];\n\n  /**\n   * For box border.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineDashOffset\n   */\n  lineDashOffset?: number;\n\n  /**\n   * For box border.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin\n   */\n  lineJoin?: CanvasLineJoin;\n\n  /**\n   * Width of box border\n   */\n  lineWidth?: number;\n\n  /**\n   * Stroke style of the legend box\n   */\n  strokeStyle?: Color;\n\n  /**\n   * Point style of the legend box (only used if usePointStyle is true)\n   */\n  pointStyle?: PointStyle;\n\n  /**\n   * Rotation of the point in degrees (only used if usePointStyle is true)\n   */\n  rotation?: number;\n\n  /**\n   * Text alignment\n   */\n  textAlign?: TextAlign;\n}\n\nexport interface LegendElement<TType extends ChartType> extends Element<AnyObject, LegendOptions<TType>>, LayoutItem {\n  chart: Chart<TType>;\n  ctx: CanvasRenderingContext2D;\n  legendItems?: LegendItem[];\n  options: LegendOptions<TType>;\n}\n\nexport interface LegendOptions<TType extends ChartType> {\n  /**\n   * Is the legend shown?\n   * @default true\n   */\n  display: boolean;\n  /**\n   * Position of the legend.\n   * @default 'top'\n   */\n  position: LayoutPosition;\n  /**\n   * Alignment of the legend.\n   * @default 'center'\n   */\n  align: Align;\n  /**\n   * Maximum height of the legend, in pixels\n   */\n  maxHeight: number;\n  /**\n   * Maximum width of the legend, in pixels\n   */\n  maxWidth: number;\n  /**\n   * Marks that this box should take the full width/height of the canvas (moving other boxes). This is unlikely to need to be changed in day-to-day use.\n   * @default true\n   */\n  fullSize: boolean;\n  /**\n   * Legend will show datasets in reverse order.\n   * @default false\n   */\n  reverse: boolean;\n  /**\n   * A callback that is called when a click event is registered on a label item.\n   */\n  onClick(this: LegendElement<TType>, e: ChartEvent, legendItem: LegendItem, legend: LegendElement<TType>): void;\n  /**\n   * A callback that is called when a 'mousemove' event is registered on top of a label item\n   */\n  onHover(this: LegendElement<TType>, e: ChartEvent, legendItem: LegendItem, legend: LegendElement<TType>): void;\n  /**\n   * A callback that is called when a 'mousemove' event is registered outside of a previously hovered label item.\n   */\n  onLeave(this: LegendElement<TType>, e: ChartEvent, legendItem: LegendItem, legend: LegendElement<TType>): void;\n\n  labels: {\n    /**\n     * Width of colored box.\n     * @default 40\n     */\n    boxWidth: number;\n    /**\n     * Height of the coloured box.\n     * @default fontSize\n     */\n    boxHeight: number;\n    /**\n     * Padding between the color box and the text\n     * @default 1\n     */\n    boxPadding: number;\n    /**\n     * Color of label\n     * @see Defaults.color\n     */\n    color: Color;\n    /**\n     * Font of label\n     * @see Defaults.font\n     */\n    font: ScriptableAndScriptableOptions<Partial<FontSpec>, ScriptableChartContext>;\n    /**\n     * Padding between rows of colored boxes.\n     * @default 10\n     */\n    padding: number;\n    /**\n     * If usePointStyle is true, the width of the point style used for the legend.\n     */\n    pointStyleWidth: number;\n    /**\n     * Generates legend items for each thing in the legend. Default implementation returns the text + styling for the color box. See Legend Item for details.\n     */\n    generateLabels(chart: Chart): LegendItem[];\n\n    /**\n     * Filters legend items out of the legend. Receives 2 parameters, a Legend Item and the chart data\n     */\n    filter(item: LegendItem, data: ChartData): boolean;\n\n    /**\n     * Sorts the legend items\n     */\n    sort(a: LegendItem, b: LegendItem, data: ChartData): number;\n\n    /**\n     * Override point style for the legend. Only applies if usePointStyle is true\n     */\n    pointStyle: PointStyle;\n\n    /**\n     * Text alignment\n     */\n    textAlign?: TextAlign;\n\n    /**\n     * Label style will match corresponding point style (size is based on the minimum value between boxWidth and font.size).\n     * @default false\n     */\n    usePointStyle: boolean;\n\n    /**\n     * Label borderRadius will match corresponding borderRadius.\n     * @default false\n     */\n    useBorderRadius: boolean;\n\n    /**\n     * Override the borderRadius to use.\n     * @default undefined\n     */\n    borderRadius: number;\n  };\n  /**\n   * true for rendering the legends from right to left.\n   */\n  rtl: boolean;\n  /**\n   * This will force the text direction 'rtl' or 'ltr' on the canvas for rendering the legend, regardless of the css specified on the canvas\n   * @default canvas's default\n   */\n  textDirection: string;\n\n  title: {\n    /**\n     * Is the legend title displayed.\n     * @default false\n     */\n    display: boolean;\n    /**\n     * Color of title\n     * @see Defaults.color\n     */\n    color: Color;\n    /**\n     * see Fonts\n     */\n    font: ScriptableAndScriptableOptions<Partial<FontSpec>, ScriptableChartContext>;\n    position: 'center' | 'start' | 'end';\n    padding?: number | ChartArea;\n    /**\n     * The string title.\n     */\n    text: string;\n  };\n}\n\nexport declare const SubTitle: Plugin;\nexport declare const Title: Plugin;\n\nexport interface TitleOptions {\n  /**\n   * Alignment of the title.\n   * @default 'center'\n   */\n  align: Align;\n  /**\n   * Is the title shown?\n   * @default false\n   */\n  display: boolean;\n  /**\n   * Position of title\n   * @default 'top'\n   */\n  position: 'top' | 'left' | 'bottom' | 'right';\n  /**\n   * Color of text\n   * @see Defaults.color\n   */\n  color: Color;\n  font: ScriptableAndScriptableOptions<Partial<FontSpec>, ScriptableChartContext>;\n\n  /**\n   * Marks that this box should take the full width/height of the canvas (moving other boxes). If set to `false`, places the box above/beside the\n   * chart area\n   * @default true\n   */\n  fullSize: boolean;\n  /**\n   *   Adds padding above and below the title text if a single number is specified. It is also possible to change top and bottom padding separately.\n   */\n  padding: number | { top: number; bottom: number };\n  /**\n   *   Title text to display. If specified as an array, text is rendered on multiple lines.\n   */\n  text: string | string[];\n}\n\nexport type TooltipXAlignment = 'left' | 'center' | 'right';\nexport type TooltipYAlignment = 'top' | 'center' | 'bottom';\nexport interface TooltipLabelStyle {\n  borderColor: Color;\n  backgroundColor: Color;\n\n  /**\n   * Width of border line\n   * @since 3.1.0\n   */\n  borderWidth?: number;\n\n  /**\n   * Border dash\n   * @since 3.1.0\n   */\n  borderDash?: [number, number];\n\n  /**\n   * Border dash offset\n   * @since 3.1.0\n   */\n  borderDashOffset?: number;\n\n  /**\n   * borderRadius\n   * @since 3.1.0\n   */\n  borderRadius?: number | BorderRadius;\n}\nexport interface TooltipModel<TType extends ChartType> extends Element<AnyObject, TooltipOptions<TType>> {\n  readonly chart: Chart<TType>;\n\n  // The items that we are rendering in the tooltip. See Tooltip Item Interface section\n  dataPoints: TooltipItem<TType>[];\n\n  // Positioning\n  xAlign: TooltipXAlignment;\n  yAlign: TooltipYAlignment;\n\n  // X and Y properties are the top left of the tooltip\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  // Where the tooltip points to\n  caretX: number;\n  caretY: number;\n\n  // Body\n  // The body lines that need to be rendered\n  // Each object contains 3 parameters\n  // before: string[] // lines of text before the line with the color square\n  // lines: string[]; // lines of text to render as the main item with color square\n  // after: string[]; // lines of text to render after the main lines\n  body: { before: string[]; lines: string[]; after: string[] }[];\n  // lines of text that appear after the title but before the body\n  beforeBody: string[];\n  // line of text that appear after the body and before the footer\n  afterBody: string[];\n\n  // Title\n  // lines of text that form the title\n  title: string[];\n\n  // Footer\n  // lines of text that form the footer\n  footer: string[];\n\n  // Styles to render for each item in body[]. This is the styling of the squares in the tooltip\n  labelColors: TooltipLabelStyle[];\n  labelTextColors: Color[];\n  labelPointStyles: { pointStyle: PointStyle; rotation: number }[];\n\n  // 0 opacity is a hidden tooltip\n  opacity: number;\n\n  // tooltip options\n  options: TooltipOptions<TType>;\n\n  getActiveElements(): ActiveElement[];\n  setActiveElements(active: ActiveDataPoint[], eventPosition: Point): void;\n}\n\nexport interface TooltipPosition extends Point {\n  xAlign?: TooltipXAlignment;\n  yAlign?: TooltipYAlignment;\n}\n\nexport type TooltipPositionerFunction<TType extends ChartType> = (\n  this: TooltipModel<TType>,\n  items: readonly ActiveElement[],\n  eventPosition: Point\n) => TooltipPosition | false;\n\nexport interface TooltipPositionerMap {\n  average: TooltipPositionerFunction<ChartType>;\n  nearest: TooltipPositionerFunction<ChartType>;\n}\n\nexport type TooltipPositioner = keyof TooltipPositionerMap;\n\nexport interface Tooltip extends Plugin {\n  readonly positioners: TooltipPositionerMap;\n}\n\nexport declare const Tooltip: Tooltip;\n\nexport interface TooltipCallbacks<\n  TType extends ChartType,\n  Model = TooltipModel<TType>,\n  Item = TooltipItem<TType>> {\n\n  beforeTitle(this: Model, tooltipItems: Item[]): string | string[] | void;\n  title(this: Model, tooltipItems: Item[]): string | string[] | void;\n  afterTitle(this: Model, tooltipItems: Item[]): string | string[] | void;\n\n  beforeBody(this: Model, tooltipItems: Item[]): string | string[] | void;\n  afterBody(this: Model, tooltipItems: Item[]): string | string[] | void;\n\n  beforeLabel(this: Model, tooltipItem: Item): string | string[] | void;\n  label(this: Model, tooltipItem: Item): string | string[] | void;\n  afterLabel(this: Model, tooltipItem: Item): string | string[] | void;\n\n  labelColor(this: Model, tooltipItem: Item): TooltipLabelStyle | void;\n  labelTextColor(this: Model, tooltipItem: Item): Color | void;\n  labelPointStyle(this: Model, tooltipItem: Item): { pointStyle: PointStyle; rotation: number } | void;\n\n  beforeFooter(this: Model, tooltipItems: Item[]): string | string[] | void;\n  footer(this: Model, tooltipItems: Item[]): string | string[] | void;\n  afterFooter(this: Model, tooltipItems: Item[]): string | string[] | void;\n}\n\nexport interface ExtendedPlugin<\n  TType extends ChartType,\n  O = AnyObject,\n  Model = TooltipModel<TType>> {\n  /**\n   * @desc Called before drawing the `tooltip`. If any plugin returns `false`,\n   * the tooltip drawing is cancelled until another `render` is triggered.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {Tooltip} args.tooltip - The tooltip.\n   * @param {object} options - The plugin options.\n   * @returns {boolean} `false` to cancel the chart tooltip drawing.\n   */\n  beforeTooltipDraw?(chart: Chart, args: { tooltip: Model, cancelable: true }, options: O): boolean | void;\n  /**\n   * @desc Called after drawing the `tooltip`. Note that this hook will not\n   * be called if the tooltip drawing has been previously cancelled.\n   * @param {Chart} chart - The chart instance.\n   * @param {object} args - The call arguments.\n   * @param {Tooltip} args.tooltip - The tooltip.\n   * @param {object} options - The plugin options.\n   */\n  afterTooltipDraw?(chart: Chart, args: { tooltip: Model }, options: O): void;\n}\n\nexport interface ScriptableTooltipContext<TType extends ChartType> {\n  chart: UnionToIntersection<Chart<TType>>;\n  tooltip: UnionToIntersection<TooltipModel<TType>>;\n  tooltipItems: TooltipItem<TType>[];\n}\n\nexport interface TooltipOptions<TType extends ChartType = ChartType> extends CoreInteractionOptions {\n  /**\n   * Are on-canvas tooltips enabled?\n   * @default true\n   */\n  enabled: Scriptable<boolean, ScriptableTooltipContext<TType>>;\n  /**\n   *   See external tooltip section.\n   */\n  external(this: TooltipModel<TType>, args: { chart: Chart; tooltip: TooltipModel<TType> }): void;\n  /**\n   * The mode for positioning the tooltip\n   */\n  position: Scriptable<TooltipPositioner, ScriptableTooltipContext<TType>>\n\n  /**\n   * Override the tooltip alignment calculations\n   */\n  xAlign: Scriptable<TooltipXAlignment, ScriptableTooltipContext<TType>>;\n  yAlign: Scriptable<TooltipYAlignment, ScriptableTooltipContext<TType>>;\n\n  /**\n   * Sort tooltip items.\n   */\n  itemSort: (a: TooltipItem<TType>, b: TooltipItem<TType>, data: ChartData) => number;\n\n  filter: (e: TooltipItem<TType>, index: number, array: TooltipItem<TType>[], data: ChartData) => boolean;\n\n  /**\n   * Background color of the tooltip.\n   * @default 'rgba(0, 0, 0, 0.8)'\n   */\n  backgroundColor: Scriptable<Color, ScriptableTooltipContext<TType>>;\n  /**\n   * Padding between the color box and the text.\n   * @default 1\n   */\n  boxPadding: number;\n  /**\n   * Color of title\n   * @default '#fff'\n   */\n  titleColor: Scriptable<Color, ScriptableTooltipContext<TType>>;\n  /**\n   * See Fonts\n   * @default {weight: 'bold'}\n   */\n  titleFont: ScriptableAndScriptableOptions<Partial<FontSpec>, ScriptableTooltipContext<TType>>;\n  /**\n   * Spacing to add to top and bottom of each title line.\n   * @default 2\n   */\n  titleSpacing: Scriptable<number, ScriptableTooltipContext<TType>>;\n  /**\n   * Margin to add on bottom of title section.\n   * @default 6\n   */\n  titleMarginBottom: Scriptable<number, ScriptableTooltipContext<TType>>;\n  /**\n   * Horizontal alignment of the title text lines.\n   * @default 'left'\n   */\n  titleAlign: Scriptable<TextAlign, ScriptableTooltipContext<TType>>;\n  /**\n   * Spacing to add to top and bottom of each tooltip item.\n   * @default 2\n   */\n  bodySpacing: Scriptable<number, ScriptableTooltipContext<TType>>;\n  /**\n   * Color of body\n   * @default '#fff'\n   */\n  bodyColor: Scriptable<Color, ScriptableTooltipContext<TType>>;\n  /**\n   * See Fonts.\n   * @default {}\n   */\n  bodyFont: ScriptableAndScriptableOptions<Partial<FontSpec>, ScriptableTooltipContext<TType>>;\n  /**\n   * Horizontal alignment of the body text lines.\n   * @default 'left'\n   */\n  bodyAlign: Scriptable<TextAlign, ScriptableTooltipContext<TType>>;\n  /**\n   * Spacing to add to top and bottom of each footer line.\n   * @default 2\n   */\n  footerSpacing: Scriptable<number, ScriptableTooltipContext<TType>>;\n  /**\n   * Margin to add before drawing the footer.\n   * @default 6\n   */\n  footerMarginTop: Scriptable<number, ScriptableTooltipContext<TType>>;\n  /**\n   * Color of footer\n   * @default '#fff'\n   */\n  footerColor: Scriptable<Color, ScriptableTooltipContext<TType>>;\n  /**\n   * See Fonts\n   * @default {weight: 'bold'}\n   */\n  footerFont: ScriptableAndScriptableOptions<Partial<FontSpec>, ScriptableTooltipContext<TType>>;\n  /**\n   * Horizontal alignment of the footer text lines.\n   * @default 'left'\n   */\n  footerAlign: Scriptable<TextAlign, ScriptableTooltipContext<TType>>;\n  /**\n   * Padding to add to the tooltip\n   * @default 6\n   */\n  padding: Scriptable<Padding, ScriptableTooltipContext<TType>>;\n  /**\n   * Extra distance to move the end of the tooltip arrow away from the tooltip point.\n   * @default 2\n   */\n  caretPadding: Scriptable<number, ScriptableTooltipContext<TType>>;\n  /**\n   * Size, in px, of the tooltip arrow.\n   * @default 5\n   */\n  caretSize: Scriptable<number, ScriptableTooltipContext<TType>>;\n  /**\n   * Radius of tooltip corner curves.\n   * @default 6\n   */\n  cornerRadius: Scriptable<number | BorderRadius, ScriptableTooltipContext<TType>>;\n  /**\n   * Color to draw behind the colored boxes when multiple items are in the tooltip.\n   * @default '#fff'\n   */\n  multiKeyBackground: Scriptable<Color, ScriptableTooltipContext<TType>>;\n  /**\n   * If true, color boxes are shown in the tooltip.\n   * @default true\n   */\n  displayColors: Scriptable<boolean, ScriptableTooltipContext<TType>>;\n  /**\n   * Width of the color box if displayColors is true.\n   * @default bodyFont.size\n   */\n  boxWidth: Scriptable<number, ScriptableTooltipContext<TType>>;\n  /**\n   * Height of the color box if displayColors is true.\n   * @default bodyFont.size\n   */\n  boxHeight: Scriptable<number, ScriptableTooltipContext<TType>>;\n  /**\n   * Use the corresponding point style (from dataset options) instead of color boxes, ex: star, triangle etc. (size is based on the minimum value between boxWidth and boxHeight)\n   * @default false\n   */\n  usePointStyle: Scriptable<boolean, ScriptableTooltipContext<TType>>;\n  /**\n   * Color of the border.\n   * @default 'rgba(0, 0, 0, 0)'\n   */\n  borderColor: Scriptable<Color, ScriptableTooltipContext<TType>>;\n  /**\n   * Size of the border.\n   * @default 0\n   */\n  borderWidth: Scriptable<number, ScriptableTooltipContext<TType>>;\n  /**\n   * true for rendering the legends from right to left.\n   */\n  rtl: Scriptable<boolean, ScriptableTooltipContext<TType>>;\n\n  /**\n   * This will force the text direction 'rtl' or 'ltr on the canvas for rendering the tooltips, regardless of the css specified on the canvas\n   * @default canvas's default\n   */\n  textDirection: Scriptable<string, ScriptableTooltipContext<TType>>;\n\n  animation: AnimationSpec<TType> | false;\n  animations: AnimationsSpec<TType> | false;\n  callbacks: TooltipCallbacks<TType>;\n}\n\nexport interface TooltipItem<TType extends ChartType> {\n  /**\n   * The chart the tooltip is being shown on\n   */\n  chart: Chart;\n\n  /**\n   * Label for the tooltip\n   */\n  label: string;\n\n  /**\n   * Parsed data values for the given `dataIndex` and `datasetIndex`\n   */\n  parsed: UnionToIntersection<ParsedDataType<TType>>;\n\n  /**\n   * Raw data values for the given `dataIndex` and `datasetIndex`\n   */\n  raw: unknown;\n\n  /**\n   * Formatted value for the tooltip\n   */\n  formattedValue: string;\n\n  /**\n   * The dataset the item comes from\n   */\n  dataset: UnionToIntersection<ChartDataset<TType>>;\n\n  /**\n   * Index of the dataset the item comes from\n   */\n  datasetIndex: number;\n\n  /**\n   * Index of this data item in the dataset\n   */\n  dataIndex: number;\n\n  /**\n   * The chart element (point, arc, bar, etc.) for this tooltip item\n   */\n  element: Element;\n}\n\nexport interface PluginOptionsByType<TType extends ChartType> {\n  colors: ColorsPluginOptions;\n  decimation: DecimationOptions;\n  filler: FillerOptions;\n  legend: LegendOptions<TType>;\n  subtitle: TitleOptions;\n  title: TitleOptions;\n  tooltip: TooltipOptions<TType>;\n}\nexport interface PluginChartOptions<TType extends ChartType> {\n  plugins: PluginOptionsByType<TType>;\n}\n\nexport interface BorderOptions {\n  /**\n   * @default true\n   */\n  display: boolean\n  /**\n   * @default []\n   */\n  dash: Scriptable<number[], ScriptableScaleContext>;\n  /**\n   * @default 0\n   */\n  dashOffset: Scriptable<number, ScriptableScaleContext>;\n  color: Color;\n  width: number;\n  z: number;\n}\n\nexport interface GridLineOptions {\n  /**\n   * @default true\n   */\n  display: boolean;\n  /**\n   * @default false\n   */\n  circular: boolean;\n  /**\n   * @default 'rgba(0, 0, 0, 0.1)'\n   */\n  color: ScriptableAndArray<Color, ScriptableScaleContext>;\n  /**\n   * @default 1\n   */\n  lineWidth: ScriptableAndArray<number, ScriptableScaleContext>;\n  /**\n   * @default true\n   */\n  drawOnChartArea: boolean;\n  /**\n   * @default true\n   */\n  drawTicks: boolean;\n  /**\n   * @default []\n   */\n  tickBorderDash: Scriptable<number[], ScriptableScaleContext>;\n  /**\n   * @default 0\n   */\n  tickBorderDashOffset: Scriptable<number, ScriptableScaleContext>;\n  /**\n   * @default 'rgba(0, 0, 0, 0.1)'\n   */\n  tickColor: ScriptableAndArray<Color, ScriptableScaleContext>;\n  /**\n   * @default 10\n   */\n  tickLength: number;\n  /**\n   * @default 1\n   */\n  tickWidth: number;\n  /**\n   * @default false\n   */\n  offset: boolean;\n  /**\n   * @default 0\n   */\n  z: number;\n}\n\nexport interface TickOptions {\n  /**\n   * Color of label backdrops.\n   * @default 'rgba(255, 255, 255, 0.75)'\n   */\n  backdropColor: Scriptable<Color, ScriptableScaleContext>;\n  /**\n   * Padding of tick backdrop.\n   * @default 2\n   */\n  backdropPadding: number | ChartArea;\n\n  /**\n   * Returns the string representation of the tick value as it should be displayed on the chart. See callback.\n   */\n  callback: (this: Scale, tickValue: number | string, index: number, ticks: Tick[]) => string | string[] | number | number[] | null | undefined;\n  /**\n   * If true, show tick labels.\n   * @default true\n   */\n  display: boolean;\n  /**\n   * Color of tick\n   * @see Defaults.color\n   */\n  color: ScriptableAndArray<Color, ScriptableScaleContext>;\n  /**\n   * see Fonts\n   */\n  font: ScriptableAndScriptableOptions<Partial<FontSpec>, ScriptableScaleContext>;\n  /**\n   * Sets the offset of the tick labels from the axis\n   */\n  padding: number;\n  /**\n   * If true, draw a background behind the tick labels.\n   * @default false\n   */\n  showLabelBackdrop: Scriptable<boolean, ScriptableScaleContext>;\n  /**\n   * The color of the stroke around the text.\n   * @default undefined\n   */\n  textStrokeColor: Scriptable<Color, ScriptableScaleContext>;\n  /**\n   * Stroke width around the text.\n   * @default 0\n   */\n  textStrokeWidth: Scriptable<number, ScriptableScaleContext>;\n  /**\n   * z-index of tick layer. Useful when ticks are drawn on chart area. Values <= 0 are drawn under datasets, > 0 on top.\n   * @default 0\n   */\n  z: number;\n\n  major: {\n    /**\n     * If true, major ticks are generated. A major tick will affect autoskipping and major will be defined on ticks in the scriptable options context.\n     * @default false\n     */\n    enabled: boolean;\n  };\n}\n\nexport type CartesianTickOptions = TickOptions & {\n  /**\n   * The number of ticks to examine when deciding how many labels will fit. Setting a smaller value will be faster, but may be less accurate when there is large variability in label length.\n   * @default ticks.length\n   */\n  sampleSize: number;\n  /**\n   * The label alignment\n   * @default 'center'\n   */\n  align: Align | 'inner';\n  /**\n   *   If true, automatically calculates how many labels can be shown and hides labels accordingly. Labels will be rotated up to maxRotation before skipping any. Turn autoSkip off to show all labels no matter what.\n   * @default true\n   */\n  autoSkip: boolean;\n  /**\n   * Padding between the ticks on the horizontal axis when autoSkip is enabled.\n   * @default 0\n   */\n  autoSkipPadding: number;\n\n  /**\n   * How is the label positioned perpendicular to the axis direction.\n   * This only applies when the rotation is 0 and the axis position is one of \"top\", \"left\", \"right\", or \"bottom\"\n   * @default 'near'\n   */\n  crossAlign: 'near' | 'center' | 'far';\n\n  /**\n   * Should the defined `min` and `max` values be presented as ticks even if they are not \"nice\".\n   * @default: true\n   */\n  includeBounds: boolean;\n\n  /**\n   * Distance in pixels to offset the label from the centre point of the tick (in the x direction for the x axis, and the y direction for the y axis). Note: this can cause labels at the edges to be cropped by the edge of the canvas\n   * @default 0\n   */\n  labelOffset: number;\n\n  /**\n   * Minimum rotation for tick labels. Note: Only applicable to horizontal scales.\n   * @default 0\n   */\n  minRotation: number;\n  /**\n   * Maximum rotation for tick labels when rotating to condense labels. Note: Rotation doesn't occur until necessary. Note: Only applicable to horizontal scales.\n   * @default 50\n   */\n  maxRotation: number;\n  /**\n   * Flips tick labels around axis, displaying the labels inside the chart instead of outside. Note: Only applicable to vertical scales.\n   * @default false\n   */\n  mirror: boolean;\n  /**\n   *   Padding between the tick label and the axis. When set on a vertical axis, this applies in the horizontal (X) direction. When set on a horizontal axis, this applies in the vertical (Y) direction.\n   * @default 0\n   */\n  padding: number;\n  /**\n   * Maximum number of ticks and gridlines to show.\n   * @default 11\n   */\n  maxTicksLimit: number;\n}\n\nexport interface ScriptableCartesianScaleContext {\n  scale: keyof CartesianScaleTypeRegistry;\n  type: string;\n}\n\nexport interface ScriptableChartContext {\n  chart: Chart;\n  type: string;\n}\n\nexport interface CartesianScaleOptions extends CoreScaleOptions {\n  /**\n   * Scale boundary strategy (bypassed by min/max time options)\n   * - `data`: make sure data are fully visible, ticks outside are removed\n   * - `ticks`: make sure ticks are fully visible, data outside are truncated\n   * @since 2.7.0\n   * @default 'ticks'\n   */\n  bounds: 'ticks' | 'data';\n\n  /**\n   * Position of the axis.\n   */\n  position: 'left' | 'top' | 'right' | 'bottom' | 'center' | { [scale: string]: number };\n\n  /**\n   * Stack group. Axes at the same `position` with same `stack` are stacked.\n   */\n  stack?: string;\n\n  /**\n   * Weight of the scale in stack group. Used to determine the amount of allocated space for the scale within the group.\n   * @default 1\n   */\n  stackWeight?: number;\n\n  /**\n   *   Which type of axis this is. Possible values are: 'x', 'y', 'r'. If not set, this is inferred from the first character of the ID which should be 'x', 'y' or 'r'.\n   */\n  axis: 'x' | 'y' | 'r';\n\n  /**\n   * User defined minimum value for the scale, overrides minimum value from data.\n   */\n  min: number;\n\n  /**\n   * User defined maximum value for the scale, overrides maximum value from data.\n   */\n  max: number;\n\n  /**\n   *   If true, extra space is added to the both edges and the axis is scaled to fit into the chart area. This is set to true for a bar chart by default.\n   * @default false\n   */\n  offset: boolean;\n\n  grid: Partial<GridLineOptions>;\n\n  border: BorderOptions;\n\n  /** Options for the scale title. */\n  title: {\n    /** If true, displays the axis title. */\n    display: boolean;\n    /** Alignment of the axis title. */\n    align: Align;\n    /** The text for the title, e.g. \"# of People\" or \"Response Choices\". */\n    text: string | string[];\n    /** Color of the axis label. */\n    color: Color;\n    /** Information about the axis title font. */\n    font: ScriptableAndScriptableOptions<Partial<FontSpec>, ScriptableCartesianScaleContext>;\n    /** Padding to apply around scale labels. */\n    padding: number | {\n      /** Padding on the (relative) top side of this axis label. */\n      top: number;\n      /** Padding on the (relative) bottom side of this axis label. */\n      bottom: number;\n      /** This is a shorthand for defining top/bottom to the same values. */\n      y: number;\n    };\n  };\n\n  /**\n   *   If true, data will be comprised between datasets of data\n   * @default false\n   */\n  stacked?: boolean | 'single';\n\n  ticks: CartesianTickOptions;\n}\n\nexport type CategoryScaleOptions = Omit<CartesianScaleOptions, 'min' | 'max'> & {\n  min: string | number;\n  max: string | number;\n  labels: string[] | string[][];\n};\n\nexport type CategoryScale<O extends CategoryScaleOptions = CategoryScaleOptions> = Scale<O>\nexport declare const CategoryScale: ChartComponent & {\n  prototype: CategoryScale;\n  new <O extends CategoryScaleOptions = CategoryScaleOptions>(cfg: AnyObject): CategoryScale<O>;\n};\n\nexport type LinearScaleOptions = CartesianScaleOptions & {\n\n  /**\n   *  if true, scale will include 0 if it is not already included.\n   * @default true\n   */\n  beginAtZero: boolean;\n  /**\n   * Adjustment used when calculating the maximum data value.\n   */\n  suggestedMin?: number;\n  /**\n   * Adjustment used when calculating the minimum data value.\n   */\n  suggestedMax?: number;\n  /**\n  * Percentage (string ending with %) or amount (number) for added room in the scale range above and below data.\n  */\n  grace?: string | number;\n\n  ticks: {\n    /**\n     * The Intl.NumberFormat options used by the default label formatter\n     */\n    format: Intl.NumberFormatOptions;\n\n    /**\n     * if defined and stepSize is not specified, the step size will be rounded to this many decimal places.\n     */\n    precision: number;\n\n    /**\n     * User defined fixed step size for the scale\n     */\n    stepSize: number;\n\n    /**\n     * User defined count of ticks\n     */\n    count: number;\n  };\n};\n\nexport type LinearScale<O extends LinearScaleOptions = LinearScaleOptions> = Scale<O>\nexport declare const LinearScale: ChartComponent & {\n  prototype: LinearScale;\n  new <O extends LinearScaleOptions = LinearScaleOptions>(cfg: AnyObject): LinearScale<O>;\n};\n\nexport type LogarithmicScaleOptions = CartesianScaleOptions & {\n  /**\n   * Adjustment used when calculating the maximum data value.\n   */\n  suggestedMin?: number;\n  /**\n   * Adjustment used when calculating the minimum data value.\n   */\n  suggestedMax?: number;\n\n  ticks: {\n    /**\n     * The Intl.NumberFormat options used by the default label formatter\n     */\n    format: Intl.NumberFormatOptions;\n  };\n};\n\nexport type LogarithmicScale<O extends LogarithmicScaleOptions = LogarithmicScaleOptions> = Scale<O>\nexport declare const LogarithmicScale: ChartComponent & {\n  prototype: LogarithmicScale;\n  new <O extends LogarithmicScaleOptions = LogarithmicScaleOptions>(cfg: AnyObject): LogarithmicScale<O>;\n};\n\nexport type TimeScaleTimeOptions = {\n  /**\n   * Custom parser for dates.\n   */\n  parser: string | ((v: unknown) => number);\n  /**\n   * If defined, dates will be rounded to the start of this unit. See Time Units below for the allowed units.\n   */\n  round: false | TimeUnit;\n  /**\n   * If boolean and true and the unit is set to 'week', then the first day of the week will be Monday. Otherwise, it will be Sunday.\n   * If `number`, the index of the first day of the week (0 - Sunday, 6 - Saturday).\n   * @default false\n   */\n  isoWeekday: boolean | number;\n  /**\n   * Sets how different time units are displayed.\n   */\n  displayFormats: {\n    [key: string]: string;\n  };\n  /**\n   * The format string to use for the tooltip.\n   */\n  tooltipFormat: string;\n  /**\n   * If defined, will force the unit to be a certain type. See Time Units section below for details.\n   * @default false\n   */\n  unit: false | TimeUnit;\n  /**\n   * The minimum display format to be used for a time unit.\n   * @default 'millisecond'\n   */\n  minUnit: TimeUnit;\n};\n\nexport type TimeScaleTickOptions = {\n  /**\n   * Ticks generation input values:\n   * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n   * - 'data': generates ticks from data (including labels from data `{t|x|y}` objects).\n   * - 'labels': generates ticks from user given `data.labels` values ONLY.\n   * @see https://github.com/chartjs/Chart.js/pull/4507\n   * @since 2.7.0\n   * @default 'auto'\n   */\n  source: 'labels' | 'auto' | 'data';\n  /**\n   * The number of units between grid lines.\n   * @default 1\n   */\n  stepSize: number;\n};\n\nexport type TimeScaleOptions = Omit<CartesianScaleOptions, 'min' | 'max'> & {\n  min: string | number;\n  max: string | number;\n  suggestedMin: string | number;\n  suggestedMax: string | number;\n  /**\n   * Scale boundary strategy (bypassed by min/max time options)\n   * - `data`: make sure data are fully visible, ticks outside are removed\n   * - `ticks`: make sure ticks are fully visible, data outside are truncated\n   * @since 2.7.0\n   * @default 'data'\n   */\n  bounds: 'ticks' | 'data';\n\n  /**\n   * If true, bar chart offsets are computed with skipped tick sizes\n   * @since 3.8.0\n   * @default false\n   */\n  offsetAfterAutoskip: boolean;\n\n  /**\n   * options for creating a new adapter instance\n   */\n  adapters: {\n    date: unknown;\n  };\n\n  time: TimeScaleTimeOptions;\n\n  ticks: TimeScaleTickOptions;\n};\n\nexport interface TimeScale<O extends TimeScaleOptions = TimeScaleOptions> extends Scale<O> {\n  format(value: number, format?: string): string;\n  getDataTimestamps(): number[];\n  getLabelTimestamps(): string[];\n  normalize(values: number[]): number[];\n}\n\nexport declare const TimeScale: ChartComponent & {\n  prototype: TimeScale;\n  new <O extends TimeScaleOptions = TimeScaleOptions>(cfg: AnyObject): TimeScale<O>;\n};\n\nexport type TimeSeriesScale<O extends TimeScaleOptions = TimeScaleOptions> = TimeScale<O>\nexport declare const TimeSeriesScale: ChartComponent & {\n  prototype: TimeSeriesScale;\n  new <O extends TimeScaleOptions = TimeScaleOptions>(cfg: AnyObject): TimeSeriesScale<O>;\n};\n\nexport type RadialTickOptions = TickOptions & {\n  /**\n   * The Intl.NumberFormat options used by the default label formatter\n   */\n  format: Intl.NumberFormatOptions;\n\n  /**\n   * Maximum number of ticks and gridlines to show.\n   * @default 11\n   */\n  maxTicksLimit: number;\n\n  /**\n   * if defined and stepSize is not specified, the step size will be rounded to this many decimal places.\n   */\n  precision: number;\n\n  /**\n   * User defined fixed step size for the scale.\n   */\n  stepSize: number;\n\n  /**\n   * User defined number of ticks\n   */\n  count: number;\n}\n\nexport type RadialLinearScaleOptions = CoreScaleOptions & {\n  animate: boolean;\n\n  startAngle: number;\n\n  angleLines: {\n    /**\n     * if true, angle lines are shown.\n     * @default true\n     */\n    display: boolean;\n    /**\n     * Color of angled lines.\n     * @default 'rgba(0, 0, 0, 0.1)'\n     */\n    color: Scriptable<Color, ScriptableScaleContext>;\n    /**\n     * Width of angled lines.\n     * @default 1\n     */\n    lineWidth: Scriptable<number, ScriptableScaleContext>;\n    /**\n     * Length and spacing of dashes on angled lines. See MDN.\n     * @default []\n     */\n    borderDash: Scriptable<number[], ScriptableScaleContext>;\n    /**\n     * Offset for line dashes. See MDN.\n     * @default 0\n     */\n    borderDashOffset: Scriptable<number, ScriptableScaleContext>;\n  };\n\n  /**\n   * if true, scale will include 0 if it is not already included.\n   * @default false\n   */\n  beginAtZero: boolean;\n\n  grid: Partial<GridLineOptions>;\n\n  /**\n   * User defined minimum number for the scale, overrides minimum value from data.\n   */\n  min: number;\n  /**\n   * User defined maximum number for the scale, overrides maximum value from data.\n   */\n  max: number;\n\n  pointLabels: {\n    /**\n     * Background color of the point label.\n     * @default undefined\n     */\n    backdropColor: Scriptable<Color, ScriptableScalePointLabelContext>;\n    /**\n     * Padding of label backdrop.\n     * @default 2\n     */\n    backdropPadding: Scriptable<number | ChartArea, ScriptableScalePointLabelContext>;\n\n    /**\n     * Border radius\n     * @default 0\n     * @since 3.8.0\n     */\n    borderRadius: Scriptable<number | BorderRadius, ScriptableScalePointLabelContext>;\n\n    /**\n     * if true, point labels are shown. When `display: 'auto'`, the label is hidden if it overlaps with another label.\n     * @default true\n     */\n    display: boolean | 'auto';\n    /**\n     * Color of label\n     * @see Defaults.color\n     */\n    color: Scriptable<Color, ScriptableScalePointLabelContext>;\n    /**\n     */\n    font: ScriptableAndScriptableOptions<Partial<FontSpec>, ScriptableScalePointLabelContext>;\n\n    /**\n     * Callback function to transform data labels to point labels. The default implementation simply returns the current string.\n     */\n    callback: (label: string, index: number) => string | string[] | number | number[];\n\n    /**\n     * Padding around the pointLabels\n     * @default 5\n     */\n    padding: Scriptable<number, ScriptableScalePointLabelContext>;\n\n    /**\n     * if true, point labels are centered.\n     * @default false\n     */\n    centerPointLabels: boolean;\n  };\n\n  /**\n   * Adjustment used when calculating the maximum data value.\n   */\n  suggestedMax: number;\n  /**\n   * Adjustment used when calculating the minimum data value.\n   */\n  suggestedMin: number;\n\n  ticks: RadialTickOptions;\n};\n\nexport interface RadialLinearScale<O extends RadialLinearScaleOptions = RadialLinearScaleOptions> extends Scale<O> {\n  setCenterPoint(leftMovement: number, rightMovement: number, topMovement: number, bottomMovement: number): void;\n  getIndexAngle(index: number): number;\n  getDistanceFromCenterForValue(value: number): number;\n  getValueForDistanceFromCenter(distance: number): number;\n  getPointPosition(index: number, distanceFromCenter: number): { x: number; y: number; angle: number };\n  getPointPositionForValue(index: number, value: number): { x: number; y: number; angle: number };\n  getPointLabelPosition(index: number): ChartArea;\n  getBasePosition(index: number): { x: number; y: number; angle: number };\n}\nexport declare const RadialLinearScale: ChartComponent & {\n  prototype: RadialLinearScale;\n  new <O extends RadialLinearScaleOptions = RadialLinearScaleOptions>(cfg: AnyObject): RadialLinearScale<O>;\n};\n\nexport interface CartesianScaleTypeRegistry {\n  linear: {\n    options: LinearScaleOptions;\n  };\n  logarithmic: {\n    options: LogarithmicScaleOptions;\n  };\n  category: {\n    options: CategoryScaleOptions;\n  };\n  time: {\n    options: TimeScaleOptions;\n  };\n  timeseries: {\n    options: TimeScaleOptions;\n  };\n}\n\nexport interface RadialScaleTypeRegistry {\n  radialLinear: {\n    options: RadialLinearScaleOptions;\n  };\n}\n\nexport interface ScaleTypeRegistry extends CartesianScaleTypeRegistry, RadialScaleTypeRegistry {\n}\n\nexport type ScaleType = keyof ScaleTypeRegistry;\n\nexport interface CartesianParsedData extends Point {\n  // Only specified when stacked bars are enabled\n  _stacks?: {\n    // Key is the stack ID which is generally the axis ID\n    [key: string]: {\n      // Inner key is the datasetIndex\n      [key: number]: number;\n    }\n  }\n}\n\ninterface BarParsedData extends CartesianParsedData {\n  // Only specified if floating bars are show\n  _custom?: {\n    barStart: number;\n    barEnd: number;\n    start: number;\n    end: number;\n    min: number;\n    max: number;\n  }\n}\n\ninterface BubbleParsedData extends CartesianParsedData {\n  // The bubble radius value\n  _custom: number;\n}\n\ninterface RadialParsedData {\n  r: number;\n}\n\nexport interface ChartTypeRegistry {\n  bar: {\n    chartOptions: BarControllerChartOptions;\n    datasetOptions: BarControllerDatasetOptions;\n    defaultDataPoint: number | [number, number] | null;\n    metaExtensions: {};\n    parsedDataType: BarParsedData,\n    scales: keyof CartesianScaleTypeRegistry;\n  };\n  line: {\n    chartOptions: LineControllerChartOptions;\n    datasetOptions: LineControllerDatasetOptions & FillerControllerDatasetOptions;\n    defaultDataPoint: ScatterDataPoint | number | null;\n    metaExtensions: {};\n    parsedDataType: CartesianParsedData;\n    scales: keyof CartesianScaleTypeRegistry;\n  };\n  scatter: {\n    chartOptions: ScatterControllerChartOptions;\n    datasetOptions: ScatterControllerDatasetOptions;\n    defaultDataPoint: ScatterDataPoint | number | null;\n    metaExtensions: {};\n    parsedDataType: CartesianParsedData;\n    scales: keyof CartesianScaleTypeRegistry;\n  };\n  bubble: {\n    chartOptions: unknown;\n    datasetOptions: BubbleControllerDatasetOptions;\n    defaultDataPoint: BubbleDataPoint;\n    metaExtensions: {};\n    parsedDataType: BubbleParsedData;\n    scales: keyof CartesianScaleTypeRegistry;\n  };\n  pie: {\n    chartOptions: PieControllerChartOptions;\n    datasetOptions: PieControllerDatasetOptions;\n    defaultDataPoint: PieDataPoint;\n    metaExtensions: PieMetaExtensions;\n    parsedDataType: number;\n    scales: keyof CartesianScaleTypeRegistry;\n  };\n  doughnut: {\n    chartOptions: DoughnutControllerChartOptions;\n    datasetOptions: DoughnutControllerDatasetOptions;\n    defaultDataPoint: DoughnutDataPoint;\n    metaExtensions: DoughnutMetaExtensions;\n    parsedDataType: number;\n    scales: keyof CartesianScaleTypeRegistry;\n  };\n  polarArea: {\n    chartOptions: PolarAreaControllerChartOptions;\n    datasetOptions: PolarAreaControllerDatasetOptions;\n    defaultDataPoint: number;\n    metaExtensions: {};\n    parsedDataType: RadialParsedData;\n    scales: keyof RadialScaleTypeRegistry;\n  };\n  radar: {\n    chartOptions: RadarControllerChartOptions;\n    datasetOptions: RadarControllerDatasetOptions & FillerControllerDatasetOptions;\n    defaultDataPoint: number | null;\n    metaExtensions: {};\n    parsedDataType: RadialParsedData;\n    scales: keyof RadialScaleTypeRegistry;\n  };\n}\n\nexport type ChartType = keyof ChartTyppeRegistry;\n\nexport type ScaleOptionsByType<TScale extends ScaleType = ScaleType> =\n  { [key in ScaleType]: { type: key } & ScaleTypeRegistry[key]['options'] }[TScale]\n;\n\n// Convenience alias for creating and manipulating scale options in user code\nexport type ScaleOptions<TScale extends ScaleType = ScaleType> = DeepPartial<ScaleOptionsByType<TScale>>;\n\nexport type DatasetChartOptions<TType extends ChartType = ChartType> = {\n  [key in TType]: {\n    datasets: ChartTypeRegistry[key]['datasetOptions'];\n  };\n};\n\nexport type ScaleChartOptions<TType extends ChartType = ChartType> = {\n  scales: {\n    [key: string]: ScaleOptionsByType<ChartTypeRegistry[TType]['scales']>;\n  };\n};\n\nexport type ChartOptions<TType extends ChartType = ChartType> = DeepPartial<\nCoreChartOptions<TType> &\nElementChartOptions<TType> &\nPluginChartOptions<TType> &\nDatasetChartOptions<TType> &\nScaleChartOptions<TType> &\nChartTypeRegistry[TType]['chartOptions']\n>;\n\nexport type DefaultDataPoint<TType extends ChartType> = DistributiveArray<ChartTypeRegistry[TType]['defaultDataPoint']>;\n\nexport type ParsedDataType<TType extends ChartType = ChartType> = ChartTypeRegistry[TType]['parsedDataType'];\n\nexport interface ChartDatasetProperties<TType extends ChartType, TData> {\n  type?: TType;\n  data: TData;\n}\n\nexport interface ChartDatasetPropertiesCustomTypesPerDataset<TType extends ChartType, TData> {\n  type: TType;\n  data: TData;\n}\n\nexport type ChartDataset<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>\n> = DeepPartial<\n{ [key in ChartType]: { type: key } & ChartTypeRegistry[key]['datasetOptions'] }[TType]\n> & ChartDatasetProperties<TType, TData>;\n\nexport type ChartDatasetCustomTypesPerDataset<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>\n> = DeepPartial<\n{ [key in ChartType]: { type: key } & ChartTypeRegistry[key]['datasetOptions'] }[TType]\n> & ChartDatasetPropertiesCustomTypesPerDataset<TType, TData>;\n\n/**\n * TData represents the data point type. If unspecified, a default is provided\n *   based on the chart type.\n * TLabel represents the label type\n */\nexport interface ChartData<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown\n> {\n  labels?: TLabel[];\n  xLabels?: TLabel[];\n  yLabels?: TLabel[];\n  datasets: ChartDataset<TType, TData>[];\n}\n\nexport interface ChartDataCustomTypesPerDataset<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown\n> {\n  labels?: TLabel[];\n  xLabels?: TLabel[];\n  yLabels?: TLabel[];\n  datasets: ChartDatasetCustomTypesPerDataset<TType, TData>[];\n}\n\nexport interface ChartConfiguration<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown\n> {\n  type: TType;\n  data: ChartData<TType, TData, TLabel>;\n  options?: ChartOptions<TType>;\n  plugins?: Plugin<TType>[];\n  platform?: typeof BasePlatform;\n}\n\nexport interface ChartConfigurationCustomTypesPerDataset<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown\n> {\n  data: ChartDataCustomTypesPerDataset<TType, TData, TLabel>;\n  options?: ChartOptions<TType>;\n  plugins?: Plugin<TType>[];\n}\n"
        }
    ]
}