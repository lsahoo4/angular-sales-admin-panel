{
    "sourceFile": "src/app/product/product-table/product-table-datasource.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1704253658841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1704254469625,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,114 @@\n+import { DataSource } from '@angular/cdk/collections';\n+import { MatPaginator } from '@angular/material/paginator';\n+import { MatSort } from '@angular/material/sort';\n+import { map } from 'rxjs/operators';\n+import { Observable, of as observableOf, merge } from 'rxjs';\n+\n+// TODO: Replace this with your own data model type\n+export interface ProductTableItem {\n+  name: string;\n+  id: number;\n+  price: number;\n+  description: string;\n+}\n+\n+// TODO: replace this with real data from your application\n+const EXAMPLE_DATA: ProductTableItem[] = [\n+  {id: 1, name: 'Hydrogen', price: 100, description: 'Hydrogen desc'},\n+  {id: 2, name: 'Helium',price: 100, description: 'Helium desc'},\n+  {id: 3, name: 'Lithium',price: 100, description: 'Lithium desc'},\n+  {id: 4, name: 'Beryllium',price: 100, description: 'Beryllium desc'},\n+  {id: 5, name: 'Boron',price: 100, description: 'Boron desc'},\n+  {id: 6, name: 'Carbon',price: 100, description: 'Carbon desc'},\n+  {id: 7, name: 'Nitrogen',price: 100, description: 'Nitrogen desc'},\n+  {id: 8, name: 'Oxygen',price: 100, description: 'Oxygen desc'},\n+  {id: 9, name: 'Fluorine',price: 100, description: 'Fluorine desc'},\n+  {id: 10, name: 'Neon',price: 100, description: 'Neon desc'},\n+  {id: 11, name: 'Sodium',price: 100, description: 'Sodium desc'},\n+  {id: 12, name: 'Magnesium',price: 100, description: 'Magnesium desc'},\n+  {id: 13, name: 'Aluminum',price: 100, description: 'Aluminum desc'},\n+  {id: 14, name: 'Silicon',price: 100, description: 'Silicon desc'},\n+  {id: 15, name: 'Phosphorus',price: 100, description: 'Phosphorus desc'},\n+  {id: 16, name: 'Sulfur',price: 100, description: 'Sulfur desc'},\n+  {id: 17, name: 'Chlorine',price: 100, description: 'Chlorine desc'},\n+  {id: 18, name: 'Argon',price: 100, description: 'Argon desc'},\n+  {id: 19, name: 'Potassium',price: 100, description: 'Potassium desc'},\n+  {id: 20, name: 'Calcium',price: 100, description: 'Calcium desc'},\n+];\n+\n+/**\n+ * Data source for the ProductTable view. This class should\n+ * encapsulate all logic for fetching and manipulating the displayed data\n+ * (including sorting, pagination, and filtering).\n+ */\n+export class ProductTableDataSource extends DataSource<ProductTableItem> {\n+  data: ProductTableItem[] = EXAMPLE_DATA;\n+  paginator: MatPaginator | undefined;\n+  sort: MatSort | undefined;\n+  filter: string | undefined\n+\n+  constructor() {\n+    super();\n+  }\n+\n+  /**\n+   * Connect this data source to the table. The table will only update when\n+   * the returned stream emits new items.\n+   * @returns A stream of the items to be rendered.\n+   */\n+  connect(): Observable<ProductTableItem[]> {\n+    if (this.paginator && this.sort) {\n+      // Combine everything that affects the rendered data into one update\n+      // stream for the data-table to consume.\n+      return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange)\n+        .pipe(map(() => {\n+          return this.getPagedData(this.getSortedData([...this.data ]));\n+        }));\n+    } else {\n+      throw Error('Please set the paginator and sort on the data source before connecting.');\n+    }\n+  }\n+\n+  /**\n+   *  Called when the table is being destroyed. Use this function, to clean up\n+   * any open connections or free any held resources that were set up during connect.\n+   */\n+  disconnect(): void {}\n+\n+  /**\n+   * Paginate the data (client-side). If you're using server-side pagination,\n+   * this would be replaced by requesting the appropriate data from the server.\n+   */\n+  private getPagedData(data: ProductTableItem[]): ProductTableItem[] {\n+    if (this.paginator) {\n+      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n+      return data.splice(startIndex, this.paginator.pageSize);\n+    } else {\n+      return data;\n+    }\n+  }\n+\n+  /**\n+   * Sort the data (client-side). If you're using server-side sorting,\n+   * this would be replaced by requesting the appropriate data from the server.\n+   */\n+  private getSortedData(data: ProductTableItem[]): ProductTableItem[] {\n+    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n+      return data;\n+    }\n+\n+    return data.sort((a, b) => {\n+      const isAsc = this.sort?.direction === 'asc';\n+      switch (this.sort?.active) {\n+        case 'name': return compare(a.name, b.name, isAsc);\n+        case 'id': return compare(+a.id, +b.id, isAsc);\n+        default: return 0;\n+      }\n+    });\n+  }\n+}\n+\n+/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\n+function compare(a: string | number, b: string | number, isAsc: boolean): number {\n+  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n+}\n"
                },
                {
                    "date": 1704256977027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n   {id: 12, name: 'Magnesium',price: 100, description: 'Magnesium desc'},\n   {id: 13, name: 'Aluminum',price: 100, description: 'Aluminum desc'},\n   {id: 14, name: 'Silicon',price: 100, description: 'Silicon desc'},\n   {id: 15, name: 'Phosphorus',price: 100, description: 'Phosphorus desc'},\n-  {id: 16, name: 'Sulfur',price: 100, description: 'Sulfur desc'},\n+  {id: 16, name: 'Sulfur',price: 200, description: 'Sulfur desc'},\n   {id: 17, name: 'Chlorine',price: 100, description: 'Chlorine desc'},\n   {id: 18, name: 'Argon',price: 100, description: 'Argon desc'},\n   {id: 19, name: 'Potassium',price: 100, description: 'Potassium desc'},\n   {id: 20, name: 'Calcium',price: 100, description: 'Calcium desc'},\n@@ -111,117 +111,4 @@\n /** Simple sort comparator for example ID/Name columns (for client-side sorting). */\n function compare(a: string | number, b: string | number, isAsc: boolean): number {\n   return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n }\n-import { DataSource } from '@angular/cdk/collections';\n-import { MatPaginator } from '@angular/material/paginator';\n-import { MatSort } from '@angular/material/sort';\n-import { map } from 'rxjs/operators';\n-import { Observable, of as observableOf, merge } from 'rxjs';\n-\n-// TODO: Replace this with your own data model type\n-export interface ProductTableItem {\n-  name: string;\n-  id: number;\n-  price: number;\n-  description: string;\n-}\n-\n-// TODO: replace this with real data from your application\n-const EXAMPLE_DATA: ProductTableItem[] = [\n-  {id: 1, name: 'Hydrogen', price: 100, description: 'Hydrogen desc'},\n-  {id: 2, name: 'Helium',price: 100, description: 'Helium desc'},\n-  {id: 3, name: 'Lithium',price: 100, description: 'Lithium desc'},\n-  {id: 4, name: 'Beryllium',price: 100, description: 'Beryllium desc'},\n-  {id: 5, name: 'Boron',price: 100, description: 'Boron desc'},\n-  {id: 6, name: 'Carbon',price: 100, description: 'Carbon desc'},\n-  {id: 7, name: 'Nitrogen',price: 100, description: 'Nitrogen desc'},\n-  {id: 8, name: 'Oxygen',price: 100, description: 'Oxygen desc'},\n-  {id: 9, name: 'Fluorine',price: 100, description: 'Fluorine desc'},\n-  {id: 10, name: 'Neon',price: 100, description: 'Neon desc'},\n-  {id: 11, name: 'Sodium',price: 100, description: 'Sodium desc'},\n-  {id: 12, name: 'Magnesium',price: 100, description: 'Magnesium desc'},\n-  {id: 13, name: 'Aluminum',price: 100, description: 'Aluminum desc'},\n-  {id: 14, name: 'Silicon',price: 100, description: 'Silicon desc'},\n-  {id: 15, name: 'Phosphorus',price: 100, description: 'Phosphorus desc'},\n-  {id: 16, name: 'Sulfur',price: 100, description: 'Sulfur desc'},\n-  {id: 17, name: 'Chlorine',price: 100, description: 'Chlorine desc'},\n-  {id: 18, name: 'Argon',price: 100, description: 'Argon desc'},\n-  {id: 19, name: 'Potassium',price: 100, description: 'Potassium desc'},\n-  {id: 20, name: 'Calcium',price: 100, description: 'Calcium desc'},\n-];\n-\n-/**\n- * Data source for the ProductTable view. This class should\n- * encapsulate all logic for fetching and manipulating the displayed data\n- * (including sorting, pagination, and filtering).\n- */\n-export class ProductTableDataSource extends DataSource<ProductTableItem> {\n-  data: ProductTableItem[] = EXAMPLE_DATA;\n-  paginator: MatPaginator | undefined;\n-  sort: MatSort | undefined;\n-\n-  constructor() {\n-    super();\n-  }\n-\n-  /**\n-   * Connect this data source to the table. The table will only update when\n-   * the returned stream emits new items.\n-   * @returns A stream of the items to be rendered.\n-   */\n-  connect(): Observable<ProductTableItem[]> {\n-    if (this.paginator && this.sort) {\n-      // Combine everything that affects the rendered data into one update\n-      // stream for the data-table to consume.\n-      return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange)\n-        .pipe(map(() => {\n-          return this.getPagedData(this.getSortedData([...this.data ]));\n-        }));\n-    } else {\n-      throw Error('Please set the paginator and sort on the data source before connecting.');\n-    }\n-  }\n-\n-  /**\n-   *  Called when the table is being destroyed. Use this function, to clean up\n-   * any open connections or free any held resources that were set up during connect.\n-   */\n-  disconnect(): void {}\n-\n-  /**\n-   * Paginate the data (client-side). If you're using server-side pagination,\n-   * this would be replaced by requesting the appropriate data from the server.\n-   */\n-  private getPagedData(data: ProductTableItem[]): ProductTableItem[] {\n-    if (this.paginator) {\n-      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n-      return data.splice(startIndex, this.paginator.pageSize);\n-    } else {\n-      return data;\n-    }\n-  }\n-\n-  /**\n-   * Sort the data (client-side). If you're using server-side sorting,\n-   * this would be replaced by requesting the appropriate data from the server.\n-   */\n-  private getSortedData(data: ProductTableItem[]): ProductTableItem[] {\n-    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n-      return data;\n-    }\n-\n-    return data.sort((a, b) => {\n-      const isAsc = this.sort?.direction === 'asc';\n-      switch (this.sort?.active) {\n-        case 'name': return compare(a.name, b.name, isAsc);\n-        case 'id': return compare(+a.id, +b.id, isAsc);\n-        default: return 0;\n-      }\n-    });\n-  }\n-}\n-\n-/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\n-function compare(a: string | number, b: string | number, isAsc: boolean): number {\n-  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n-}\n"
                },
                {
                    "date": 1704257073365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,116 @@\n+import { DataSource } from '@angular/cdk/collections';\n+import { MatPaginator } from '@angular/material/paginator';\n+import { MatSort } from '@angular/material/sort';\n+import { map } from 'rxjs/operators';\n+import { Observable, of as observableOf, merge } from 'rxjs';\n+\n+// TODO: Replace this with your own data model type\n+export interface ProductTableItem {\n+  name: string;\n+  id: number;\n+  price: number;\n+  description: string;\n+}\n+\n+// TODO: replace this with real data from your application\n+const EXAMPLE_DATA: ProductTableItem[] = [\n+  {id: 1, name: 'Hydrogen', price: 100, description: 'Hydrogen desc'},\n+  {id: 2, name: 'Helium',price: 100, description: 'Helium desc'},\n+  {id: 3, name: 'Lithium',price: 100, description: 'Lithium desc'},\n+  {id: 4, name: 'Beryllium',price: 100, description: 'Beryllium desc'},\n+  {id: 5, name: 'Boron',price: 100, description: 'Boron desc'},\n+  {id: 6, name: 'Carbon',price: 100, description: 'Carbon desc'},\n+  {id: 7, name: 'Nitrogen',price: 100, description: 'Nitrogen desc'},\n+  {id: 8, name: 'Oxygen',price: 100, description: 'Oxygen desc'},\n+  {id: 9, name: 'Fluorine',price: 100, description: 'Fluorine desc'},\n+  {id: 10, name: 'Neon',price: 100, description: 'Neon desc'},\n+  {id: 11, name: 'Sodium',price: 100, description: 'Sodium desc'},\n+  {id: 12, name: 'Magnesium',price: 100, description: 'Magnesium desc'},\n+  {id: 13, name: 'Aluminum',price: 100, description: 'Aluminum desc'},\n+  {id: 14, name: 'Silicon',price: 100, description: 'Silicon desc'},\n+  {id: 15, name: 'Phosphorus',price: 100, description: 'Phosphorus desc'},\n+  {id: 16, name: 'Sulfur',price: 200, description: 'Sulfur desc'},\n+  {id: 17, name: 'Chlorine',price: 100, description: 'Chlorine desc'},\n+  {id: 18, name: 'Argon',price: 100, description: 'Argon desc'},\n+  {id: 19, name: 'Potassium',price: 100, description: 'Potassium desc'},\n+  {id: 20, name: 'Calcium',price: 100, description: 'Calcium desc'},\n+];\n+\n+/**\n+ * Data source for the ProductTable view. This class should\n+ * encapsulate all logic for fetching and manipulating the displayed data\n+ * (including sorting, pagination, and filtering).\n+ */\n+export class ProductTableDataSource extends DataSource<ProductTableItem> {\n+  data: ProductTableItem[] = EXAMPLE_DATA;\n+  paginator: MatPaginator | undefined;\n+  sort: MatSort | undefined;\n+  filter: string | undefined\n+\n+  constructor() {\n+    super();\n+  }\n+\n+  /**\n+   * Connect this data source to the table. The table will only update when\n+   * the returned stream emits new items.\n+   * @returns A stream of the items to be rendered.\n+   */\n+  connect(): Observable<ProductTableItem[]> {\n+    if (this.paginator && this.sort) {\n+      // Combine everything that affects the rendered data into one update\n+      // stream for the data-table to consume.\n+      return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange)\n+        .pipe(map(() => {\n+          return this.getPagedData(this.getSortedData([...this.data ]));\n+        }));\n+    } else {\n+      throw Error('Please set the paginator and sort on the data source before connecting.');\n+    }\n+  }\n+\n+  /**\n+   *  Called when the table is being destroyed. Use this function, to clean up\n+   * any open connections or free any held resources that were set up during connect.\n+   */\n+  disconnect(): void {}\n+\n+  /**\n+   * Paginate the data (client-side). If you're using server-side pagination,\n+   * this would be replaced by requesting the appropriate data from the server.\n+   */\n+  private getPagedData(data: ProductTableItem[]): ProductTableItem[] {\n+    if (this.paginator) {\n+      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n+      return data.splice(startIndex, this.paginator.pageSize);\n+    } else {\n+      return data;\n+    }\n+  }\n+\n+  /**\n+   * Sort the data (client-side). If you're using server-side sorting,\n+   * this would be replaced by requesting the appropriate data from the server.\n+   */\n+  private getSortedData(data: ProductTableItem[]): ProductTableItem[] {\n+    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n+      return data;\n+    }\n+\n+    return data.sort((a, b) => {\n+      const isAsc = this.sort?.direction === 'asc';\n+      switch (this.sort?.active) {\n+        case 'name': return compare(a.name, b.name, isAsc);\n+        case 'id': return compare(+a.id, +b.id, isAsc);\n+        case 'price': return compare(a.price, b.price, isAsc);\n+        case 'description': return compare(a.description, b.description, isAsc);\n+        default: return 0;\n+      }\n+    });\n+  }\n+}\n+\n+/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\n+function compare(a: string | number, b: string | number, isAsc: boolean): number {\n+  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n+}\n"
                },
                {
                    "date": 1704260419291,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,10 @@\n       // Combine everything that affects the rendered data into one update\n       // stream for the data-table to consume.\n       return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange)\n         .pipe(map(() => {\n-          return this.getPagedData(this.getSortedData([...this.data ]));\n+          // return this.getPagedData(this.getSortedData([...this.data ]));\n+          return [];\n         }));\n     } else {\n       throw Error('Please set the paginator and sort on the data source before connecting.');\n     }\n@@ -113,118 +114,4 @@\n /** Simple sort comparator for example ID/Name columns (for client-side sorting). */\n function compare(a: string | number, b: string | number, isAsc: boolean): number {\n   return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n }\n-import { DataSource } from '@angular/cdk/collections';\n-import { MatPaginator } from '@angular/material/paginator';\n-import { MatSort } from '@angular/material/sort';\n-import { map } from 'rxjs/operators';\n-import { Observable, of as observableOf, merge } from 'rxjs';\n-\n-// TODO: Replace this with your own data model type\n-export interface ProductTableItem {\n-  name: string;\n-  id: number;\n-  price: number;\n-  description: string;\n-}\n-\n-// TODO: replace this with real data from your application\n-const EXAMPLE_DATA: ProductTableItem[] = [\n-  {id: 1, name: 'Hydrogen', price: 100, description: 'Hydrogen desc'},\n-  {id: 2, name: 'Helium',price: 100, description: 'Helium desc'},\n-  {id: 3, name: 'Lithium',price: 100, description: 'Lithium desc'},\n-  {id: 4, name: 'Beryllium',price: 100, description: 'Beryllium desc'},\n-  {id: 5, name: 'Boron',price: 100, description: 'Boron desc'},\n-  {id: 6, name: 'Carbon',price: 100, description: 'Carbon desc'},\n-  {id: 7, name: 'Nitrogen',price: 100, description: 'Nitrogen desc'},\n-  {id: 8, name: 'Oxygen',price: 100, description: 'Oxygen desc'},\n-  {id: 9, name: 'Fluorine',price: 100, description: 'Fluorine desc'},\n-  {id: 10, name: 'Neon',price: 100, description: 'Neon desc'},\n-  {id: 11, name: 'Sodium',price: 100, description: 'Sodium desc'},\n-  {id: 12, name: 'Magnesium',price: 100, description: 'Magnesium desc'},\n-  {id: 13, name: 'Aluminum',price: 100, description: 'Aluminum desc'},\n-  {id: 14, name: 'Silicon',price: 100, description: 'Silicon desc'},\n-  {id: 15, name: 'Phosphorus',price: 100, description: 'Phosphorus desc'},\n-  {id: 16, name: 'Sulfur',price: 200, description: 'Sulfur desc'},\n-  {id: 17, name: 'Chlorine',price: 100, description: 'Chlorine desc'},\n-  {id: 18, name: 'Argon',price: 100, description: 'Argon desc'},\n-  {id: 19, name: 'Potassium',price: 100, description: 'Potassium desc'},\n-  {id: 20, name: 'Calcium',price: 100, description: 'Calcium desc'},\n-];\n-\n-/**\n- * Data source for the ProductTable view. This class should\n- * encapsulate all logic for fetching and manipulating the displayed data\n- * (including sorting, pagination, and filtering).\n- */\n-export class ProductTableDataSource extends DataSource<ProductTableItem> {\n-  data: ProductTableItem[] = EXAMPLE_DATA;\n-  paginator: MatPaginator | undefined;\n-  sort: MatSort | undefined;\n-  filter: string | undefined\n-\n-  constructor() {\n-    super();\n-  }\n-\n-  /**\n-   * Connect this data source to the table. The table will only update when\n-   * the returned stream emits new items.\n-   * @returns A stream of the items to be rendered.\n-   */\n-  connect(): Observable<ProductTableItem[]> {\n-    if (this.paginator && this.sort) {\n-      // Combine everything that affects the rendered data into one update\n-      // stream for the data-table to consume.\n-      return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange)\n-        .pipe(map(() => {\n-          return this.getPagedData(this.getSortedData([...this.data ]));\n-        }));\n-    } else {\n-      throw Error('Please set the paginator and sort on the data source before connecting.');\n-    }\n-  }\n-\n-  /**\n-   *  Called when the table is being destroyed. Use this function, to clean up\n-   * any open connections or free any held resources that were set up during connect.\n-   */\n-  disconnect(): void {}\n-\n-  /**\n-   * Paginate the data (client-side). If you're using server-side pagination,\n-   * this would be replaced by requesting the appropriate data from the server.\n-   */\n-  private getPagedData(data: ProductTableItem[]): ProductTableItem[] {\n-    if (this.paginator) {\n-      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n-      return data.splice(startIndex, this.paginator.pageSize);\n-    } else {\n-      return data;\n-    }\n-  }\n-\n-  /**\n-   * Sort the data (client-side). If you're using server-side sorting,\n-   * this would be replaced by requesting the appropriate data from the server.\n-   */\n-  private getSortedData(data: ProductTableItem[]): ProductTableItem[] {\n-    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n-      return data;\n-    }\n-\n-    return data.sort((a, b) => {\n-      const isAsc = this.sort?.direction === 'asc';\n-      switch (this.sort?.active) {\n-        case 'name': return compare(a.name, b.name, isAsc);\n-        case 'id': return compare(+a.id, +b.id, isAsc);\n-        default: return 0;\n-      }\n-    });\n-  }\n-}\n-\n-/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\n-function compare(a: string | number, b: string | number, isAsc: boolean): number {\n-  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n-}\n"
                },
                {
                    "date": 1704260473502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,9 +62,9 @@\n       // stream for the data-table to consume.\n       return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange)\n         .pipe(map(() => {\n           // return this.getPagedData(this.getSortedData([...this.data ]));\n-          return [];\n+          return this.getPagedData(this.getSortedData([...this.data ]));\n         }));\n     } else {\n       throw Error('Please set the paginator and sort on the data source before connecting.');\n     }\n"
                },
                {
                    "date": 1704260518751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,8 @@\n       // Combine everything that affects the rendered data into one update\n       // stream for the data-table to consume.\n       return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange)\n         .pipe(map(() => {\n-          // return this.getPagedData(this.getSortedData([...this.data ]));\n           return this.getPagedData(this.getSortedData([...this.data ]));\n         }));\n     } else {\n       throw Error('Please set the paginator and sort on the data source before connecting.');\n"
                },
                {
                    "date": 1704265029094,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n   description: string;\n }\n \n // TODO: replace this with real data from your application\n-const EXAMPLE_DATA: ProductTableItem[] = [\n+export const EXAMPLE_PRODUCT_DATA: ProductTableItem[] = [\n   {id: 1, name: 'Hydrogen', price: 100, description: 'Hydrogen desc'},\n   {id: 2, name: 'Helium',price: 100, description: 'Helium desc'},\n   {id: 3, name: 'Lithium',price: 100, description: 'Lithium desc'},\n   {id: 4, name: 'Beryllium',price: 100, description: 'Beryllium desc'},\n@@ -41,9 +41,9 @@\n  * encapsulate all logic for fetching and manipulating the displayed data\n  * (including sorting, pagination, and filtering).\n  */\n export class ProductTableDataSource extends DataSource<ProductTableItem> {\n-  data: ProductTableItem[] = EXAMPLE_DATA;\n+  data: ProductTableItem[] = EXAMPLE_PRODUCT_DATA;\n   paginator: MatPaginator | undefined;\n   sort: MatSort | undefined;\n   filter: string | undefined\n \n"
                }
            ],
            "date": 1704253658841,
            "name": "Commit-0",
            "content": "import { DataSource } from '@angular/cdk/collections';\nimport { MatPaginator } from '@angular/material/paginator';\nimport { MatSort } from '@angular/material/sort';\nimport { map } from 'rxjs/operators';\nimport { Observable, of as observableOf, merge } from 'rxjs';\n\n// TODO: Replace this with your own data model type\nexport interface ProductTableItem {\n  name: string;\n  id: number;\n  price: number;\n  description: string;\n}\n\n// TODO: replace this with real data from your application\nconst EXAMPLE_DATA: ProductTableItem[] = [\n  {id: 1, name: 'Hydrogen', price: 100, description: 'Hydrogen desc'},\n  {id: 2, name: 'Helium',price: 100, description: 'Helium desc'},\n  {id: 3, name: 'Lithium',price: 100, description: 'Lithium desc'},\n  {id: 4, name: 'Beryllium',price: 100, description: 'Beryllium desc'},\n  {id: 5, name: 'Boron',price: 100, description: 'Boron desc'},\n  {id: 6, name: 'Carbon',price: 100, description: 'Carbon desc'},\n  {id: 7, name: 'Nitrogen',price: 100, description: 'Nitrogen desc'},\n  {id: 8, name: 'Oxygen',price: 100, description: 'Oxygen desc'},\n  {id: 9, name: 'Fluorine',price: 100, description: 'Fluorine desc'},\n  {id: 10, name: 'Neon',price: 100, description: 'Neon desc'},\n  {id: 11, name: 'Sodium',price: 100, description: 'Sodium desc'},\n  {id: 12, name: 'Magnesium',price: 100, description: 'Magnesium desc'},\n  {id: 13, name: 'Aluminum',price: 100, description: 'Aluminum desc'},\n  {id: 14, name: 'Silicon',price: 100, description: 'Silicon desc'},\n  {id: 15, name: 'Phosphorus',price: 100, description: 'Phosphorus desc'},\n  {id: 16, name: 'Sulfur',price: 100, description: 'Sulfur desc'},\n  {id: 17, name: 'Chlorine',price: 100, description: 'Chlorine desc'},\n  {id: 18, name: 'Argon',price: 100, description: 'Argon desc'},\n  {id: 19, name: 'Potassium',price: 100, description: 'Potassium desc'},\n  {id: 20, name: 'Calcium',price: 100, description: 'Calcium desc'},\n];\n\n/**\n * Data source for the ProductTable view. This class should\n * encapsulate all logic for fetching and manipulating the displayed data\n * (including sorting, pagination, and filtering).\n */\nexport class ProductTableDataSource extends DataSource<ProductTableItem> {\n  data: ProductTableItem[] = EXAMPLE_DATA;\n  paginator: MatPaginator | undefined;\n  sort: MatSort | undefined;\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Connect this data source to the table. The table will only update when\n   * the returned stream emits new items.\n   * @returns A stream of the items to be rendered.\n   */\n  connect(): Observable<ProductTableItem[]> {\n    if (this.paginator && this.sort) {\n      // Combine everything that affects the rendered data into one update\n      // stream for the data-table to consume.\n      return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange)\n        .pipe(map(() => {\n          return this.getPagedData(this.getSortedData([...this.data ]));\n        }));\n    } else {\n      throw Error('Please set the paginator and sort on the data source before connecting.');\n    }\n  }\n\n  /**\n   *  Called when the table is being destroyed. Use this function, to clean up\n   * any open connections or free any held resources that were set up during connect.\n   */\n  disconnect(): void {}\n\n  /**\n   * Paginate the data (client-side). If you're using server-side pagination,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  private getPagedData(data: ProductTableItem[]): ProductTableItem[] {\n    if (this.paginator) {\n      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n      return data.splice(startIndex, this.paginator.pageSize);\n    } else {\n      return data;\n    }\n  }\n\n  /**\n   * Sort the data (client-side). If you're using server-side sorting,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  private getSortedData(data: ProductTableItem[]): ProductTableItem[] {\n    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n      return data;\n    }\n\n    return data.sort((a, b) => {\n      const isAsc = this.sort?.direction === 'asc';\n      switch (this.sort?.active) {\n        case 'name': return compare(a.name, b.name, isAsc);\n        case 'id': return compare(+a.id, +b.id, isAsc);\n        default: return 0;\n      }\n    });\n  }\n}\n\n/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\nfunction compare(a: string | number, b: string | number, isAsc: boolean): number {\n  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n}\n"
        }
    ]
}