{
    "sourceFile": "src/app/customer/customer-table/customer-table-datasource.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1704174311560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1704175771996,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,12 @@\n export class CustomerTableDataSource extends DataSource<CustomerTableItem> {\n   data: CustomerTableItem[] = [];\n   paginator: MatPaginator | undefined;\n   sort: MatSort | undefined;\n+  filter: string | undefined;\n \n+\n+\n   constructor() {\n     super();\n   }\n \n"
                }
            ],
            "date": 1704174311560,
            "name": "Commit-0",
            "content": "import { DataSource } from '@angular/cdk/collections';\nimport { MatPaginator } from '@angular/material/paginator';\nimport { MatSort } from '@angular/material/sort';\nimport { map } from 'rxjs/operators';\nimport { Observable, of as observableOf, merge } from 'rxjs';\n\n// TODO: Replace this with your own data model type\nexport interface CustomerTableItem {\n  firstName: string;\n  lastName: number;\n  email: string;\n  phone: string;\n  address: Address\n\n}\n\nexport interface Address {\n   city: string;\n   state: string;\n   pincode: string;\n}\n\n// TODO: replace this with real data from your application\n// const EXAMPLE_DATA: CustomerTableItem[] = [\n//   {id: 1, name: 'Hydrogen'},\n//   {id: 2, name: 'Helium'},\n//   {id: 3, name: 'Lithium'},\n//   {id: 4, name: 'Beryllium'},\n//   {id: 5, name: 'Boron'},\n//   {id: 6, name: 'Carbon'},\n//   {id: 7, name: 'Nitrogen'},\n//   {id: 8, name: 'Oxygen'},\n//   {id: 9, name: 'Fluorine'},\n//   {id: 10, name: 'Neon'},\n//   {id: 11, name: 'Sodium'},\n//   {id: 12, name: 'Magnesium'},\n//   {id: 13, name: 'Aluminum'},\n//   {id: 14, name: 'Silicon'},\n//   {id: 15, name: 'Phosphorus'},\n//   {id: 16, name: 'Sulfur'},\n//   {id: 17, name: 'Chlorine'},\n//   {id: 18, name: 'Argon'},\n//   {id: 19, name: 'Potassium'},\n//   {id: 20, name: 'Calcium'},\n// ];\n\n/**\n * Data source for the CustomerTable view. This class should\n * encapsulate all logic for fetching and manipulating the displayed data\n * (including sorting, pagination, and filtering).\n */\nexport class CustomerTableDataSource extends DataSource<CustomerTableItem> {\n  data: CustomerTableItem[] = [];\n  paginator: MatPaginator | undefined;\n  sort: MatSort | undefined;\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Connect this data source to the table. The table will only update when\n   * the returned stream emits new items.\n   * @returns A stream of the items to be rendered.\n   */\n  connect(): Observable<CustomerTableItem[]> {\n    if (this.paginator && this.sort) {\n      // Combine everything that affects the rendered data into one update\n      // stream for the data-table to consume.\n      return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange)\n        .pipe(map(() => {\n          return this.getPagedData(this.getSortedData([...this.data ]));\n        }));\n    } else {\n      throw Error('Please set the paginator and sort on the data source before connecting.');\n    }\n  }\n\n  /**\n   *  Called when the table is being destroyed. Use this function, to clean up\n   * any open connections or free any held resources that were set up during connect.\n   */\n  disconnect(): void {}\n\n  /**\n   * Paginate the data (client-side). If you're using server-side pagination,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  private getPagedData(data: CustomerTableItem[]): CustomerTableItem[] {\n    if (this.paginator) {\n      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n      return data.splice(startIndex, this.paginator.pageSize);\n    } else {\n      return data;\n    }\n  }\n\n  /**\n   * Sort the data (client-side). If you're using server-side sorting,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  private getSortedData(data: CustomerTableItem[]): CustomerTableItem[] {\n    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n      return data;\n    }\n\n    return data.sort((a, b) => {\n      const isAsc = this.sort?.direction === 'asc';\n      switch (this.sort?.active) {\n        case 'firstName': return compare(a.firstName, b.firstName, isAsc);\n        case 'lastName': return compare(a.lastName, b.lastName, isAsc);\n        case 'email': return compare(a.email, b.email, isAsc);\n        case 'phone': return compare(a.phone, b.phone, isAsc);\n        case 'city': return compare(a.address.city, b.address.city, isAsc);\n        case 'state': return compare(a.address.state, b.address.state, isAsc);\n        case 'pincode': return compare(a.address.pincode, b.address.pincode, isAsc);\n        default: return 0;\n      }\n    });\n  }\n}\n\n/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\nfunction compare(a: string | number, b: string | number, isAsc: boolean): number {\n  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n}\n"
        }
    ]
}