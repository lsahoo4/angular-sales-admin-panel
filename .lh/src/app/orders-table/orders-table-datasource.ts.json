{
    "sourceFile": "src/app/orders-table/orders-table-datasource.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1703653510228,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1703653510228,
            "name": "Commit-0",
            "content": "import { DataSource } from '@angular/cdk/collections';\nimport { MatPaginator } from '@angular/material/paginator';\nimport { MatSort } from '@angular/material/sort';\nimport { map } from 'rxjs/operators';\nimport { Observable, of as observableOf, merge } from 'rxjs';\n\n// TODO: Replace this with your own data model type\nexport interface OrdersTableItem {\n  name: string;\n  id: number;\n}\n\n// TODO: replace this with real data from your application\nconst EXAMPLE_DATA: OrdersTableItem[] = [\n  {id: 1, name: 'Hydrogen'},\n  {id: 2, name: 'Helium'},\n  {id: 3, name: 'Lithium'},\n  {id: 4, name: 'Beryllium'},\n  {id: 5, name: 'Boron'},\n  {id: 6, name: 'Carbon'},\n  {id: 7, name: 'Nitrogen'},\n  {id: 8, name: 'Oxygen'},\n  {id: 9, name: 'Fluorine'},\n  {id: 10, name: 'Neon'},\n  {id: 11, name: 'Sodium'},\n  {id: 12, name: 'Magnesium'},\n  {id: 13, name: 'Aluminum'},\n  {id: 14, name: 'Silicon'},\n  {id: 15, name: 'Phosphorus'},\n  {id: 16, name: 'Sulfur'},\n  {id: 17, name: 'Chlorine'},\n  {id: 18, name: 'Argon'},\n  {id: 19, name: 'Potassium'},\n  {id: 20, name: 'Calcium'},\n];\n\n/**\n * Data source for the OrdersTable view. This class should\n * encapsulate all logic for fetching and manipulating the displayed data\n * (including sorting, pagination, and filtering).\n */\nexport class OrdersTableDataSource extends DataSource<OrdersTableItem> {\n  data: OrdersTableItem[] = EXAMPLE_DATA;\n  paginator: MatPaginator | undefined;\n  sort: MatSort | undefined;\n\n  constructor() {\n    super();\n  }\n\n  /**\n   * Connect this data source to the table. The table will only update when\n   * the returned stream emits new items.\n   * @returns A stream of the items to be rendered.\n   */\n  connect(): Observable<OrdersTableItem[]> {\n    if (this.paginator && this.sort) {\n      // Combine everything that affects the rendered data into one update\n      // stream for the data-table to consume.\n      return merge(observableOf(this.data), this.paginator.page, this.sort.sortChange)\n        .pipe(map(() => {\n          return this.getPagedData(this.getSortedData([...this.data ]));\n        }));\n    } else {\n      throw Error('Please set the paginator and sort on the data source before connecting.');\n    }\n  }\n\n  /**\n   *  Called when the table is being destroyed. Use this function, to clean up\n   * any open connections or free any held resources that were set up during connect.\n   */\n  disconnect(): void {}\n\n  /**\n   * Paginate the data (client-side). If you're using server-side pagination,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  private getPagedData(data: OrdersTableItem[]): OrdersTableItem[] {\n    if (this.paginator) {\n      const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n      return data.splice(startIndex, this.paginator.pageSize);\n    } else {\n      return data;\n    }\n  }\n\n  /**\n   * Sort the data (client-side). If you're using server-side sorting,\n   * this would be replaced by requesting the appropriate data from the server.\n   */\n  private getSortedData(data: OrdersTableItem[]): OrdersTableItem[] {\n    if (!this.sort || !this.sort.active || this.sort.direction === '') {\n      return data;\n    }\n\n    return data.sort((a, b) => {\n      const isAsc = this.sort?.direction === 'asc';\n      switch (this.sort?.active) {\n        case 'name': return compare(a.name, b.name, isAsc);\n        case 'id': return compare(+a.id, +b.id, isAsc);\n        default: return 0;\n      }\n    });\n  }\n}\n\n/** Simple sort comparator for example ID/Name columns (for client-side sorting). */\nfunction compare(a: string | number, b: string | number, isAsc: boolean): number {\n  return (a < b ? -1 : 1) * (isAsc ? 1 : -1);\n}\n"
        }
    ]
}